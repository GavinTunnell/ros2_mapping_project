# `Focuser.py`
```
'''
    Arducam programable zoom-lens control component.

    Copyright (c) 2019-4 Arducam <http://www.arducam.com>.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
    OR OTHER DEALINGS IN THE SOFTWARE.
'''

import sys
import time
import os

def init(bus, address):
    os.system("i2cset -y {} 0x{:02x} 0x02 0x00".format(bus, address))

def write(bus, address, value):
    value <<= 4
    os.system("i2cset -y {} 0x{:02x} 0x00 0x{:02x}".format(bus, address, value >> 8))
    os.system("i2cset -y {} 0x{:02x} 0x01 0x{:02x}".format(bus, address, value & 0xFF))

class Focuser:
    bus = None
    CHIP_I2C_ADDR = 0x0C

    def __init__(self, bus):
        self.focus_value = 0
        self.bus = bus
        self.verbose = False
        init(self.bus, self.CHIP_I2C_ADDR)
        
    def read(self):
        return self.focus_value

    def write(self, chip_addr, value):
        if value < 0:
            value = 0
        self.focus_value = value

        value = int(value / 1000.0 * 4095)

        write(self.bus, chip_addr, value)

    OPT_BASE    = 0x1000
    OPT_FOCUS   = OPT_BASE | 0x01
    OPT_ZOOM    = OPT_BASE | 0x02
    OPT_MOTOR_X = OPT_BASE | 0x03
    OPT_MOTOR_Y = OPT_BASE | 0x04
    OPT_IRCUT   = OPT_BASE | 0x05
    opts = {
        OPT_FOCUS : {
            "MIN_VALUE": 0,
            "MAX_VALUE": 1000,
            "DEF_VALUE": 0,
        },
    }
    def reset(self,opt,flag = 1):
        info = self.opts[opt]
        if info == None or info["DEF_VALUE"] == None:
            return
        self.set(opt,info["DEF_VALUE"])

    def get(self,opt,flag = 0):
        info = self.opts[opt]
        return self.read()

    def set(self,opt,value,flag = 1):
        info = self.opts[opt]
        if value > info["MAX_VALUE"]:
            value = info["MAX_VALUE"]
        elif value < info["MIN_VALUE"]:
            value = info["MIN_VALUE"]
        self.write(self.CHIP_I2C_ADDR, value)
        if self.verbose:
            print("write: {}".format(value))

pass 

def test():
    focuser = Focuser(7)
    focuser.set(Focuser.OPT_FOCUS, 0)
    time.sleep(3)
    focuser.set(Focuser.OPT_FOCUS, 1000)
    time.sleep(3)
    focuser.reset(Focuser.OPT_FOCUS)

if __name__ == "__main__":
    test()```

# `TabletJetsonComm.py`
```
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient

from geometry_msgs.msg import PoseStamped
from nav2_msgs.action import NavigateToPose


class TabletNavBridge(Node):
    def __init__(self):
        super().__init__('tablet_nav_bridge')

        # Listen for goals from the tablet
        self.goal_sub = self.create_subscription(
            PoseStamped,
            'tablet_goal',
            self.goal_callback,
            10
        )

        # Nav2 action client
        self.nav_client = ActionClient(
            self,
            NavigateToPose,
            'navigate_to_pose'
        )

        self.get_logger().info('TabletNavBridge node started. Waiting for /tablet_goal...')

    def goal_callback(self, pose_msg: PoseStamped):
        # Called whenever the tablet publishes a goal
        self.get_logger().info(
            f'Received tablet goal: x={pose_msg.pose.position.x:.2f}, '
            f'y={pose_msg.pose.position.y:.2f}'
        )

        if not self.nav_client.wait_for_server(timeout_sec=1.0):
            self.get_logger().warn('Nav2 navigate_to_pose action server not available.')
            return

        goal = NavigateToPose.Goal()
        goal.pose = pose_msg

        self.get_logger().info('Sending goal to Nav2...')
        send_future = self.nav_client.send_goal_async(goal)
        send_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().warn('Nav2 goal was rejected.')
            return

        self.get_logger().info('Nav2 goal accepted.')
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.nav_result_callback)

    def nav_result_callback(self, future):
        result = future.result()
        self.get_logger().info(f'Nav2 navigation finished with status: {result.status}')


def main(args=None):
    rclpy.init(args=args)
    node = TabletNavBridge()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

# `bringup_slam_stack.sh`
```
#!/usr/bin/env bash
set -e

###############################
# 0. Go to project root
###############################
cd "$(dirname "$0")"

###############################
# 1. Clean + setup ROS env
###############################
unset $(env | awk -F= '/^(AMENT|COLCON|ROS_|RMW_|CYCLONEDDS)/{print $1}')
source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off

echo "[bringup] Launching SLAM stack via ros2_mapping_project/bringup.launch.py..."
echo "          (EKF uses odom_params.yaml, SLAM uses slam_params.yaml)"
echo ""

# This single launch file starts:
#  - Static TFs (base_link->laser, base_link->imu_link)
#  - RPLidar node
#  - IMU node + Madgwick filter (/imu/raw -> /imu/data)
#  - Encoders node (/wheel_twist)
#  - EKF (robot_localization) with odom_params.yaml
#  - SLAM Toolbox (sync_slam_toolbox_node)
#  - RViz2
ros2 launch ros2_mapping_project bringup.launch.py
```

# `encoders_node.py`
```
#!/usr/bin/env python3
import math
import threading

import rclpy
from rclpy.node import Node

try:
    import Jetson.GPIO as GPIO
    _HAS_GPIO = True
except Exception:
    _HAS_GPIO = False

from nav_msgs.msg import Odometry
from geometry_msgs.msg import TwistWithCovarianceStamped, Quaternion, TransformStamped
from tf2_ros import TransformBroadcaster


def yaw_to_quaternion(yaw: float) -> Quaternion:
    q = Quaternion()
    half = 0.5 * yaw
    q.x = 0.0
    q.y = 0.0
    q.z = math.sin(half)
    q.w = math.cos(half)
    return q


class EncoderNode(Node):
    """
    Differential-drive wheel odometry node.

    Publishes:
      - /wheel_odom (Odometry)
      - /wheel_twist (TwistWithCovarianceStamped)

    No special "ignore vx while turning" hacks here.
    """

    def __init__(self):
        super().__init__('encoders_node')

        # --- Parameters ---
        self.declare_parameter('left_a_pin', 12)
        self.declare_parameter('left_b_pin', 16)
        self.declare_parameter('right_a_pin', 7)
        self.declare_parameter('right_b_pin', 11)

        self.declare_parameter('wheel_radius', 0.05)   # m
        self.declare_parameter('wheel_base', 0.24)     # m
        self.declare_parameter('ticks_per_rev', 333.3333)
        self.declare_parameter('publish_rate_hz', 20.0)

        # --- Read params ---
        self.left_a_pin = int(self.get_parameter('left_a_pin').value)
        self.left_b_pin = int(self.get_parameter('left_b_pin').value)
        self.right_a_pin = int(self.get_parameter('right_a_pin').value)
        self.right_b_pin = int(self.get_parameter('right_b_pin').value)

        self.wheel_radius = float(self.get_parameter('wheel_radius').value)
        self.wheel_base = float(self.get_parameter('wheel_base').value)
        self.ticks_per_rev = float(self.get_parameter('ticks_per_rev').value)
        self.publish_rate_hz = float(self.get_parameter('publish_rate_hz').value)

        # --- State ---
        self.left_ticks = 0
        self.right_ticks = 0
        self.prev_left_ticks = 0
        self.prev_right_ticks = 0

        self.x = 0.0
        self.y = 0.0
        self.yaw = 0.0

        self.last_time = self.get_clock().now()
        self.lock = threading.Lock()

        # --- Publishers + TF ---
        self.odom_pub = self.create_publisher(Odometry, 'wheel_odom', 10)
        self.twist_pub = self.create_publisher(TwistWithCovarianceStamped, 'wheel_twist', 10)
        self.tf_broadcaster = TransformBroadcaster(self)

        # --- GPIO setup ---
        if _HAS_GPIO:
            GPIO.setmode(GPIO.BOARD)
            GPIO.setwarnings(False)
            GPIO.setup(self.left_a_pin, GPIO.IN)
            GPIO.setup(self.left_b_pin, GPIO.IN)
            GPIO.setup(self.right_a_pin, GPIO.IN)
            GPIO.setup(self.right_b_pin, GPIO.IN)

            GPIO.add_event_detect(self.left_a_pin, GPIO.BOTH, callback=self._left_callback)
            GPIO.add_event_detect(self.right_a_pin, GPIO.BOTH, callback=self._right_callback)
        else:
            self.get_logger().warn("Jetson.GPIO not available; encoder pins won’t actually count.")

        self.get_logger().info(
            f"Encoders ready. L(A,B)=({self.left_a_pin},{self.left_b_pin}) "
            f"R(A,B)=({self.right_a_pin},{self.right_b_pin}) "
            f"R={self.wheel_radius:.3f}m L={self.wheel_base:.3f}m TPR={self.ticks_per_rev:.3f}"
        )

        # --- Timer ---
        period = 1.0 / self.publish_rate_hz
        self.timer = self.create_timer(period, self._timer_cb)

    # ------------------ encoder callbacks ------------------

    def _left_callback(self, channel: int):
        if not _HAS_GPIO:
            return
        a = GPIO.input(self.left_a_pin)
        b = GPIO.input(self.left_b_pin)
        with self.lock:
            if a == b:
                self.left_ticks += 1
            else:
                self.left_ticks -= 1

    def _right_callback(self, channel: int):
        if not _HAS_GPIO:
            return
        a = GPIO.input(self.right_a_pin)
        b = GPIO.input(self.right_b_pin)
        with self.lock:
            if a == b:
                self.right_ticks += 1
            else:
                self.right_ticks -= 1

    # ------------------ main timer ------------------

    def _timer_cb(self):
        now = self.get_clock().now()
        dt = (now - self.last_time).nanoseconds / 1e9
        if dt <= 0.0:
            return
        self.last_time = now

        with self.lock:
            lt = self.left_ticks
            rt = self.right_ticks

        dlt = lt - self.prev_left_ticks
        drt = rt - self.prev_right_ticks

        self.prev_left_ticks = lt
        self.prev_right_ticks = rt

        # If no new ticks, just republish pose at same spot
        if dlt == 0 and drt == 0:
            self._publish(now, 0.0, 0.0)
            return

        meters_per_tick = (2.0 * math.pi * self.wheel_radius) / self.ticks_per_rev
        dl = dlt * meters_per_tick
        dr = drt * meters_per_tick

        vl = dl / dt
        vr = dr / dt

        v = 0.5 * (vl + vr)
        omega_enc = (vr - vl) / self.wheel_base

        # Integrate pose normally
        if abs(omega_enc) < 1e-6:
            dx = v * dt * math.cos(self.yaw)
            dy = v * dt * math.sin(self.yaw)
            dtheta = 0.0
        else:
            R = v / omega_enc
            dtheta = omega_enc * dt
            dx = R * (math.sin(self.yaw + dtheta) - math.sin(self.yaw))
            dy = -R * (math.cos(self.yaw + dtheta) - math.cos(self.yaw))

        self.x += dx
        self.y += dy
        self.yaw = self._normalize_angle(self.yaw + dtheta)

        self._publish(now, v, omega_enc)

    # ------------------ publish odom/twist/tf ------------------

    def _publish(self, stamp, v: float, omega: float):
        odom = Odometry()
        odom.header.stamp = stamp.to_msg()
        odom.header.frame_id = 'odom'
        odom.child_frame_id = 'base_link'

        odom.pose.pose.position.x = self.x
        odom.pose.pose.position.y = self.y
        odom.pose.pose.position.z = 0.0
        odom.pose.pose.orientation = yaw_to_quaternion(self.yaw)

        pose_cov = [0.0] * 36
        pose_cov[0] = 0.05    # x
        pose_cov[7] = 0.05    # y
        pose_cov[35] = 0.10   # yaw
        odom.pose.covariance = pose_cov

        odom.twist.twist.linear.x = v
        odom.twist.twist.linear.y = 0.0
        odom.twist.twist.linear.z = 0.0
        odom.twist.twist.angular.x = 0.0
        odom.twist.twist.angular.y = 0.0
        odom.twist.twist.angular.z = omega

        twist_cov = [0.0] * 36
        twist_cov[0] = 0.05    # vx
        twist_cov[35] = 0.10   # wz
        odom.twist.covariance = twist_cov

        self.odom_pub.publish(odom)

        tw = TwistWithCovarianceStamped()
        tw.header.stamp = odom.header.stamp
        tw.header.frame_id = 'base_link'
        tw.twist.twist = odom.twist.twist
        tw.twist.covariance = twist_cov
        self.twist_pub.publish(tw)

        t = TransformStamped()
        t.header.stamp = odom.header.stamp
        t.header.frame_id = 'odom'
        t.child_frame_id = 'base_link'
        t.transform.translation.x = self.x
        t.transform.translation.y = self.y
        t.transform.translation.z = 0.0
        t.transform.rotation = odom.pose.pose.orientation
        self.tf_broadcaster.sendTransform(t)

    @staticmethod
    def _normalize_angle(angle: float) -> float:
        a = math.fmod(angle + math.pi, 2.0 * math.pi)
        if a < 0.0:
            a += 2.0 * math.pi
        return a - math.pi


def main(args=None):
    rclpy.init(args=args)
    node = EncoderNode()
    try:
        rclpy.spin(node)
    finally:
        if _HAS_GPIO:
            GPIO.cleanup()
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

# `enemy_approach_node.py`
```
#!/usr/bin/env python3
"""
enemy_approach_node.py

Behavior summary:
  - SEARCH:
      * Rover stopped.
      * Servo sweeps 30° ↔ 150°.
      * Autofocus sweeps.
  - ALIGN_COUPLED (on first detection):
      * Start from the angle where detection happened.
      * Servo slowly pans toward EXACTLY 90° (servo_center_deg).
      * While servo is moving, rover rotates in the opposite direction
        at a fixed speed (turn_speed_coupled = 0.8 rad/s).
      * When servo reaches 90° (within small tol), snap to 90° and go to DRIVE.
  - DRIVE:
      * Servo held at 90°.
      * Rover drives forward (forward_speed ≥ 0.35 m/s) using bbox x-error to
        adjust angular velocity. min_turn_speed=0.8 so turns don’t stall.
  - ALIGN_SERVO:
      * When bbox area ≥ 40% of frame, rover stops.
      * Servo alone pans slowly to center the target in the image.
  - FIRE:
      * When target centered after ALIGN_SERVO, laser ON for 10 s, rover stopped.
      * Then back to SEARCH.

Assumes:
  - Motor driver listens to /cmd_vel.
  - Servo is on a PCA9685 at I2C addr 0x42, channel 0 (50 Hz).
  - Laser is on Jetson BOARD pin 22 (HIGH = ON, LOW = OFF).
"""

import os
import sys
import time
import cv2
import numpy as np
import smbus

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist

from ultralytics import YOLO
import Jetson.GPIO as GPIO

# Ensure Focuser.py is importable from your package dir
sys.path.append(os.path.dirname(__file__))
from Focuser import Focuser


# ---------- PCA9685 low-level ----------
_PCA_MODE1        = 0x00
_PCA_MODE2        = 0x01
_PCA_PRESCALE     = 0xFE
_PCA_LED0_ON_L    = 0x06
_RESTART          = 0x80
_SLEEP            = 0x10
_AI               = 0x20
_OUTDRV           = 0x04  # totem-pole


def clamp(v, lo, hi):
    return lo if v < lo else hi if v > hi else v


class PCA9685LowLevel:
    def __init__(self, busnum: int, address: int, freq_hz: float):
        self.bus    = smbus.SMBus(busnum)
        self.addr   = address
        self.freq_hz= float(freq_hz)
        self._init_chip()

    def _write8(self, reg, val):
        self.bus.write_byte_data(self.addr, reg, val & 0xFF)

    def _read8(self, reg):
        return self.bus.read_byte_data(self.addr, reg)

    def _init_chip(self):
        # reset
        self._write8(_PCA_MODE1, 0x00)
        self._write8(_PCA_MODE2, _OUTDRV)
        time.sleep(0.005)
        # sleep to set prescale
        oldmode = self._read8(_PCA_MODE1)
        self._write8(_PCA_MODE1, (oldmode | _SLEEP) & 0xFF)
        prescale = int(round(25_000_000.0 / (4096.0 * self.freq_hz) - 1.0))
        prescale = max(3, min(255, prescale))
        self._write8(_PCA_PRESCALE, prescale)
        # wake, auto-increment
        self._write8(_PCA_MODE1, (oldmode & ~_SLEEP) | _AI)
        time.sleep(0.005)
        # restart
        self._write8(_PCA_MODE1, ((self._read8(_PCA_MODE1) | _RESTART) | _AI) & 0xFF)

    def set_pwm_raw(self, channel: int, on_count: int, off_count: int):
        base = _PCA_LED0_ON_L + 4 * channel
        self._write8(base + 0, on_count & 0xFF)
        self._write8(base + 1, (on_count >> 8) & 0x0F)
        self._write8(base + 2, off_count & 0xFF)
        self._write8(base + 3, (off_count >> 8) & 0x0F)

    def set_pwm_duty(self, channel: int, duty: float):
        duty = max(0.0, min(1.0, duty))
        if duty <= 0.0:
            # fully off
            self.set_pwm_raw(channel, 0, 0)
        elif duty >= 1.0:
            # fully on
            self.set_pwm_raw(channel, 0, 4095)
        else:
            off = int(round(duty * 4095))
            off = max(1, min(4094, off))
            self.set_pwm_raw(channel, 0, off)


def angle_to_duty(angle_deg: float, freq_hz: float = 50.0) -> float:
    """
    Map servo angle [0,180] to duty fraction for PCA9685 at freq_hz.
    Uses 0.5 ms -> 0°, 2.5 ms -> 180°.
    """
    MIN_US = 500
    MAX_US = 2500
    angle = max(0.0, min(180.0, float(angle_deg)))
    us = MIN_US + (MAX_US - MIN_US) * angle / 180.0
    period_us = 1_000_000.0 / freq_hz
    duty = us / period_us  # 0.0..1.0
    return duty


class EnemyApproachAutofocusNode(Node):
    STATE_SEARCH        = 0
    STATE_ALIGN_COUPLED = 1
    STATE_DRIVE         = 2
    STATE_ALIGN_SERVO   = 3
    STATE_FIRE          = 4

    def __init__(self):
        super().__init__('enemy_approach_autofocus')

        # ---- Detection params ----
        self.declare_parameter('engine_path', 'green_specific.engine')
        self.declare_parameter('device', 0)
        self.declare_parameter('imgsz', 704)
        self.declare_parameter('conf_thresh', 0.25)
        self.declare_parameter('half', True)
        self.declare_parameter('show_window', True)
        self.declare_parameter('target_label', 'toy soldier')

        # ---- Rover motion params ----
        self.declare_parameter('forward_speed', 0.35)      # m/s, >= 0.3 so motors move
        self.declare_parameter('max_turn_speed', 0.8)      # rad/s for tracking
        self.declare_parameter('min_turn_speed', 0.8)      # minimum |w| when turning
        self.declare_parameter('yaw_gain', 1.0)            # P-gain for bbox error
        self.declare_parameter('coverage_thresh', 0.40)    # 40% frame area
        self.declare_parameter('lost_timeout', 2.0)        # seconds lost → SEARCH
        self.declare_parameter('align_tol_n', 0.03)        # |x_n-0.5| tol for DRIVE align

        # Coupled align turn speed (fixed, avoids stall, user liked 0.8)
        self.declare_parameter('turn_speed_coupled', 0.8)  # rad/s

        # ---- Servo params (PCA9685) ----
        self.declare_parameter('servo_scan_min_deg', 30.0)
        self.declare_parameter('servo_scan_max_deg', 150.0)
        self.declare_parameter('servo_scan_step_deg', 1.0)
        self.declare_parameter('servo_center_deg', 90.0)      # logical straight
        self.declare_parameter('servo_center_step_deg', 1.5)  # deg per loop in ALIGN_COUPLED
        self.declare_parameter('servo_center_tol_deg', 0.2)   # when done, snap to 90

        self.declare_parameter('pca_bus', 1)
        self.declare_parameter('pca_addr', 0x42)
        self.declare_parameter('pca_freq_hz', 50.0)
        self.declare_parameter('servo_channel', 0)

        # ALIGN_SERVO fine-pan params
        self.declare_parameter('align_servo_gain_deg', 30.0)
        self.declare_parameter('align_servo_max_step_deg', 3.0)
        self.declare_parameter('align_error_tol_n', 0.02)

        # ---- Focuser params ----
        self.declare_parameter('focuser_bus', 10)
        self.declare_parameter('focus_start', 750)
        self.declare_parameter('focus_scan_step', 50)
        self.declare_parameter('focus_trim_step', 10)
        self.declare_parameter('focus_rel_drop_to_rescan', 0.40)
        self.declare_parameter('af_update_period_s', 0.25)

        # ---- Laser params ----
        self.declare_parameter('laser_pin_board', 22)
        self.declare_parameter('fire_duration', 10.0)  # seconds

        gp = self.get_parameter
        self.engine_path       = gp('engine_path').value
        self.device            = int(gp('device').value)
        self.imgsz             = int(gp('imgsz').value)
        self.conf_thresh       = float(gp('conf_thresh').value)
        self.half              = bool(gp('half').value)
        self.show_window       = bool(gp('show_window').value)
        self.target_label      = gp('target_label').value

        self.forward_speed     = float(gp('forward_speed').value)
        self.max_turn_speed    = float(gp('max_turn_speed').value)
        self.min_turn_speed    = float(gp('min_turn_speed').value)
        self.yaw_gain          = float(gp('yaw_gain').value)
        self.coverage_thresh   = float(gp('coverage_thresh').value)
        self.lost_timeout      = float(gp('lost_timeout').value)
        self.align_tol_n       = float(gp('align_tol_n').value)
        self.turn_speed_coupled= float(gp('turn_speed_coupled').value)

        self.scan_min_deg      = float(gp('servo_scan_min_deg').value)
        self.scan_max_deg      = float(gp('servo_scan_max_deg').value)
        self.scan_step_deg     = float(gp('servo_scan_step_deg').value)
        self.servo_center_deg  = float(gp('servo_center_deg').value)
        self.servo_center_step = float(gp('servo_center_step_deg').value)
        self.servo_center_tol  = float(gp('servo_center_tol_deg').value)

        self.pca_bus           = int(gp('pca_bus').value)
        self.pca_addr          = int(gp('pca_addr').value)
        self.pca_freq_hz       = float(gp('pca_freq_hz').value)
        self.servo_channel     = int(gp('servo_channel').value)

        self.align_servo_gain  = float(gp('align_servo_gain_deg').value)
        self.align_servo_max_step = float(gp('align_servo_max_step_deg').value)
        self.align_error_tol_n = float(gp('align_error_tol_n').value)

        self.focuser_bus       = int(gp('focuser_bus').value)
        self.focus_start       = int(gp('focus_start').value)
        self.focus_scan        = int(gp('focus_scan_step').value)
        self.focus_trim_step   = int(gp('focus_trim_step').value)
        self.focus_rel_drop    = float(gp('focus_rel_drop_to_rescan').value)
        self.af_update_period  = float(gp('af_update_period_s').value)

        self.laser_pin         = int(gp('laser_pin_board').value)
        self.fire_duration     = float(gp('fire_duration').value)

        # ---- Publishers / GPIO ----
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        GPIO.setwarnings(False)
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(self.laser_pin, GPIO.OUT, initial=GPIO.LOW)

        # ---- YOLO ----
        self.get_logger().info(f"Loading YOLO engine from: {self.engine_path}")
        self.model = YOLO(self.engine_path, task="detect")

        # ---- Camera (IMX519) ----
        GST = (
            "nvarguscamerasrc sensor-id=0 !"
            "video/x-raw(memory:NVMM),width=1920,height=1080,framerate=50/1,format=NV12 !"
            "nvvidconv ! video/x-raw,format=BGRx !"
            "videoconvert ! video/x-raw,format=BGR !"
            "appsink drop=true max-buffers=4 sync=false"
        )
        self.cap = cv2.VideoCapture(GST, cv2.CAP_GSTREAMER)
        if not self.cap.isOpened():
            raise RuntimeError("Failed to open IMX519 camera")

        self.frame_w = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH)) or 1920
        self.frame_h = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT)) or 1080

        if self.show_window:
            cv2.namedWindow("enemy_approach_af", cv2.WINDOW_AUTOSIZE)

        # ---- Focuser ----
        self.focuser = Focuser(bus=self.focuser_bus)
        self.focus_pos = int(self.focus_start)
        self.focuser.set(Focuser.OPT_FOCUS, self.focus_pos)
        self.af_state = 1
        self.conf_max = 0.0
        self.ideal_focus = self.focus_pos
        self.past_conf = 0.0
        self.last_af_time = time.time()

        # ---- PCA9685 servo ----
        self.pca = PCA9685LowLevel(busnum=self.pca_bus,
                                   address=self.pca_addr,
                                   freq_hz=self.pca_freq_hz)
        self.servo_angle = self.servo_center_deg
        self._set_servo(self.servo_center_deg)
        self.scan_dir = 1

        # ---- FSM ----
        self.state = self.STATE_SEARCH
        self.last_cmd_v = 0.0
        self.last_cmd_w = 0.0
        self.last_target_seen_time = None
        self.fire_start_time = None

        self.timer = self.create_timer(0.0, self.loop_once)
        self.get_logger().info("EnemyApproachAutofocusNode initialized.")

    # ---- Servo helper ----
    def _set_servo(self, angle_deg: float):
        self.servo_angle = float(clamp(angle_deg, 0.0, 180.0))
        duty = angle_to_duty(self.servo_angle, self.pca_freq_hz)
        self.pca.set_pwm_duty(self.servo_channel, duty)

    # ---- YOLO helpers ----
    @staticmethod
    def _names(r):
        try:
            return r.names
        except Exception:
            return {}

    def select_target(self, r, frame_shape):
        if len(r.boxes) == 0:
            return None

        h, w = frame_shape[:2]
        try:
            names = self._names(r)
            cls = r.boxes.cls.detach().cpu().numpy().astype(int)
            confs = r.boxes.conf.detach().cpu().numpy()
            xywh = r.boxes.xywh.detach().cpu().numpy()
        except Exception as e:
            self.get_logger().warn(f"Error parsing YOLO boxes: {e}")
            return None

        # prefer specific label if present
        target_idxs = []
        if isinstance(names, dict) and self.target_label in names.values():
            for i, cid in enumerate(cls):
                if names.get(int(cid), "") == self.target_label:
                    target_idxs.append(i)
        if target_idxs:
            idxs = target_idxs
        else:
            idxs = [int(np.argmax(confs))]

        best_i = idxs[0]
        best_conf = confs[best_i]
        for i in idxs[1:]:
            if confs[i] > best_conf:
                best_conf = confs[i]
                best_i = i

        x, y, bw, bh = xywh[best_i]
        area_ratio = (bw * bh) / float(w * h)
        x_center_px = x
        x_center_n = x / float(w)

        return {
            "x_center_px": float(x_center_px),
            "x_center_n": float(x_center_n),
            "area_ratio": float(area_ratio),
            "conf": float(best_conf),
        }

    # ---- Motion helpers ----
    def send_cmd(self, v, w, label=None):
        # enforce min_turn_speed whenever we ask for a non-zero w
        if abs(w) > 1e-3:
            if 0.0 < abs(w) < self.min_turn_speed:
                w = self.min_turn_speed * (w / abs(w))

        if abs(v - self.last_cmd_v) < 1e-3 and abs(w - self.last_cmd_w) < 1e-3:
            return
        self.last_cmd_v = v
        self.last_cmd_w = w

        msg = Twist()
        msg.linear.x = float(v)
        msg.angular.z = float(w)
        self.cmd_pub.publish(msg)
        if label:
            self.get_logger().info(f"{label}: v={v:.2f}, w={w:.2f}")

    def stop(self, label="STOP"):
        self.send_cmd(0.0, 0.0, label)

    def laser_on(self):
        GPIO.output(self.laser_pin, GPIO.HIGH)
        self.get_logger().info("Laser ON")

    def laser_off(self):
        GPIO.output(self.laser_pin, GPIO.LOW)
        self.get_logger().info("Laser OFF")

    # ---- Autofocus ----
    def update_focus(self, has_target: bool, conf: float):
        now = time.time()
        if (now - self.last_af_time) < self.af_update_period:
            return
        self.last_af_time = now

        if not has_target:
            # continuous sweep when no target
            self.focus_pos += self.focus_scan
            if self.focus_pos > 1023:
                self.focus_pos = 0
            self.focus_pos = int(clamp(self.focus_pos, 0, 1023))
            try:
                self.focuser.set(Focuser.OPT_FOCUS, self.focus_pos)
            except Exception:
                pass
            self.af_state = 1
            self.conf_max = 0.0
            self.ideal_focus = self.focus_pos
            self.past_conf = 0.0
            return

        # Target present → small AF state machine
        if self.af_state == 1:
            if conf >= self.conf_max:
                self.conf_max = conf
                self.ideal_focus = self.focus_pos
            self.focus_pos -= self.focus_scan
            if self.focus_pos <= 0:
                self.focus_pos = int(self.ideal_focus)
                self.af_state = 2
        elif self.af_state == 2:
            self.focus_pos += self.focus_trim_step
            if conf <= self.past_conf - 0.01:
                self.focus_trim_step = -self.focus_trim_step
            if self.past_conf > 0.0 and conf < (self.past_conf * (1.0 - self.focus_rel_drop)):
                self.af_state = 1
                self.focus_pos = int(self.focus_start)
                self.conf_max = 0.0
                self.ideal_focus = self.focus_pos

        self.focus_pos = int(clamp(self.focus_pos, 0, 1023))
        self.past_conf = conf
        try:
            self.focuser.set(Focuser.OPT_FOCUS, self.focus_pos)
        except Exception:
            pass

    # ---- Main loop ----
    def loop_once(self):
        ok, frame = self.cap.read()
        if not ok:
            self.get_logger().warn("Camera frame grab failed.")
            return

        now = time.time()

        results = self.model.predict(
            source=frame,
            device=self.device,
            imgsz=self.imgsz,
            conf=self.conf_thresh,
            half=self.half,
            verbose=False
        )
        r = results[0]

        det = self.select_target(r, frame.shape)
        has_target = det is not None and det["conf"] >= self.conf_thresh
        conf = det["conf"] if has_target else 0.0

        if has_target:
            self.last_target_seen_time = now

        if self.show_window:
            annotated = r.plot()
            h, w = frame.shape[:2]
            cv2.line(annotated, (w // 2, 0), (w // 2, h), (0, 255, 0), 1)
            if det is not None:
                txt = f"conf={det['conf']:.2f}, cov={det['area_ratio']:.2f}, focus={self.focus_pos}"
                cv2.putText(annotated, txt, (10, 30),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            cv2.imshow("enemy_approach_af", annotated)
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                self.get_logger().info("Key 'q' → shutdown")
                self.cleanup()
                rclpy.shutdown()
                return

        # Always keep AF updated
        self.update_focus(has_target, conf)

        # ---- FSM ----
        if self.state == self.STATE_SEARCH:
            self.stop("SEARCH")

            # Servo sweep 30–150°
            next_angle = self.servo_angle + self.scan_step_deg * self.scan_dir
            if next_angle > self.scan_max_deg:
                next_angle = self.scan_max_deg
                self.scan_dir = -1
            elif next_angle < self.scan_min_deg:
                next_angle = self.scan_min_deg
                self.scan_dir = 1
            self._set_servo(next_angle)

            if has_target:
                self.get_logger().info("Target detected → ALIGN_COUPLED")
                self.state = self.STATE_ALIGN_COUPLED
                # Note: we deliberately do NOT snap to 90° here – we start from current angle
                self.stop("SEARCH→ALIGN_COUPLED")

        elif self.state == self.STATE_ALIGN_COUPLED:
            if not has_target:
                if (self.last_target_seen_time is None) or (now - self.last_target_seen_time > self.lost_timeout):
                    self.get_logger().info("Lost target → SEARCH")
                    self.state = self.STATE_SEARCH
                    self.stop("ALIGN_COUPLED→SEARCH")
                else:
                    self.stop("ALIGN_COUPLED (brief loss)")
                return

            area = det["area_ratio"]
            x_center_n = det["x_center_n"]
            # If soldier already big enough, skip straight to ALIGN_SERVO
            if area >= self.coverage_thresh:
                self.get_logger().info("Coverage ≥ threshold in ALIGN_COUPLED → ALIGN_SERVO")
                self.state = self.STATE_ALIGN_SERVO
                self.stop("ALIGN_COUPLED→ALIGN_SERVO")
                return

            # Slowly pan servo toward 90°, and rotate rover opposite direction
            diff = self.servo_center_deg - self.servo_angle
            if abs(diff) <= self.servo_center_tol:
                # Close enough → snap to exactly 90 and move to DRIVE
                self._set_servo(self.servo_center_deg)
                self.get_logger().info("Servo reached 90° → DRIVE")
                self.state = self.STATE_DRIVE
                self.stop("ALIGN_COUPLED→DRIVE")
                return

            # Take a small step toward center
            step = clamp(diff, -self.servo_center_step, self.servo_center_step)
            new_angle = self.servo_angle + step
            self._set_servo(new_angle)

            # While servo is moving, rotate rover opposite direction
            if step > 0.0:
                # servo moving toward the right (angle increasing) → rotate rover left
                w_cmd = self.turn_speed_coupled
            else:
                # servo moving toward the left → rotate rover right
                w_cmd = -self.turn_speed_coupled

            self.send_cmd(0.0, w_cmd, "ALIGN_COUPLED (servo+rover)")

        elif self.state == self.STATE_DRIVE:
            if not has_target:
                if (self.last_target_seen_time is None) or (now - self.last_target_seen_time > self.lost_timeout):
                    self.get_logger().info("Lost target → SEARCH")
                    self.state = self.STATE_SEARCH
                    self.stop("DRIVE→SEARCH")
                else:
                    self.stop("DRIVE (brief loss)")
                return

            # Servo locked at 90° during DRIVE
            self._set_servo(self.servo_center_deg)

            area = det["area_ratio"]
            x_center_n = det["x_center_n"]
            error_n = x_center_n - 0.5

            if area >= self.coverage_thresh:
                self.get_logger().info("Coverage ≥ threshold → ALIGN_SERVO")
                self.state = self.STATE_ALIGN_SERVO
                self.stop("DRIVE→ALIGN_SERVO")
                return

            # Forward with P-controlled turn
            w_cmd = -self.yaw_gain * error_n
            w_cmd = clamp(w_cmd, -self.max_turn_speed, self.max_turn_speed)
            v_cmd = self.forward_speed
            self.send_cmd(v_cmd, w_cmd, "DRIVE")

        elif self.state == self.STATE_ALIGN_SERVO:
            # Rover stopped; servo alone pans to perfect center
            self.stop("ALIGN_SERVO")
            if not has_target:
                if (self.last_target_seen_time is None) or (now - self.last_target_seen_time > self.lost_timeout):
                    self.get_logger().info("Lost target in ALIGN_SERVO → SEARCH")
                    self.state = self.STATE_SEARCH
                    self.stop("ALIGN_SERVO→SEARCH")
                return

            x_center_n = det["x_center_n"]
            error_n = x_center_n - 0.5

            if abs(error_n) <= self.align_error_tol_n:
                self.get_logger().info("Target centered → FIRE")
                self.state = self.STATE_FIRE
                self.fire_start_time = now
                self.laser_on()
                return

            raw_step = -self.align_servo_gain * error_n
            step = clamp(raw_step, -self.align_servo_max_step, self.align_servo_max_step)
            self._set_servo(self.servo_angle + step)

        elif self.state == self.STATE_FIRE:
            self.stop("FIRE")
            if self.fire_start_time is None:
                self.fire_start_time = now
            elapsed = now - self.fire_start_time
            if elapsed >= self.fire_duration:
                self.get_logger().info("Fire complete → SEARCH")
                self.laser_off()
                self.state = self.STATE_SEARCH
                self.stop("FIRE→SEARCH")

        else:
            self.get_logger().warn(f"Unknown state {self.state}, resetting to SEARCH")
            self.state = self.STATE_SEARCH
            self.stop("Failsafe→SEARCH")

    # ---- Cleanup ----
    def cleanup(self):
        self.stop("Cleanup")
        try:
            self.laser_off()
        except Exception:
            pass
        try:
            if self.cap is not None:
                self.cap.release()
        except Exception:
            pass
        try:
            if self.show_window:
                cv2.destroyAllWindows()
        except Exception:
            pass
        try:
            self._set_servo(self.servo_center_deg)
            time.sleep(0.1)
            self.pca.set_pwm_duty(self.servo_channel, 0.0)
        except Exception:
            pass
        try:
            GPIO.cleanup(self.laser_pin)
        except Exception:
            pass


def main(args=None):
    rclpy.init(args=args)
    node = EnemyApproachAutofocusNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info("KeyboardInterrupt → shutdown")
    finally:
        node.cleanup()
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

# `final_hopefully.py`
```
import os, time, collections, cv2, numpy as np,smbus
from ultralytics import YOLO
import Jetson.GPIO as GPIO
from Focuser import Focuser  # assuming you saved your previous class
import math
# ---------- PCA9685 low-level ----------
_PCA_MODE1        = 0x00
_PCA_MODE2        = 0x01
_PCA_PRESCALE     = 0xFE
_PCA_LED0_ON_L    = 0x06
# MODE1 bits
_RESTART          = 0x80
_SLEEP            = 0x10
_AI               = 0x20
# MODE2 bits
_OUTDRV           = 0x04  # totem-pole

def sit_down_bitch(active):
    if not active:
        motors = 0
    else:
        motors = 1
    return motors

class PCA9685LowLevel:
    def __init__(self, busnum: int, address: int, freq_hz: float):
        self.bus    = smbus.SMBus(busnum)
        self.addr   = address
        self.freq_hz= float(freq_hz)
        self._init_chip()

    def _write8(self, reg, val):
        self.bus.write_byte_data(self.addr, reg, val & 0xFF)

    def _read8(self, reg):
        return self.bus.read_byte_data(self.addr, reg)

    def _init_chip(self):
        # reset
        self._write8(_PCA_MODE1, 0x00)  # all call off, AI off initially
        self._write8(_PCA_MODE2, _OUTDRV)
        time.sleep(0.005)
        # sleep to set prescale
        oldmode = self._read8(_PCA_MODE1)
        self._write8(_PCA_MODE1, (oldmode | _SLEEP) & 0xFF)
        prescale = int(round(25_000_000.0 / (4096.0 * self.freq_hz) - 1.0))
        prescale = max(3, min(255, prescale))
        self._write8(_PCA_PRESCALE, prescale)
        # wake, auto-increment
        self._write8(_PCA_MODE1, (oldmode & ~_SLEEP) | _AI)
        time.sleep(0.005)
        # restart
        self._write8(_PCA_MODE1, ((self._read8(_PCA_MODE1) | _RESTART) | _AI) & 0xFF)

    def set_pwm_raw(self, channel: int, on_count: int, off_count: int):
        base = _PCA_LED0_ON_L + 4 * channel
        self._write8(base + 0, on_count & 0xFF)
        self._write8(base + 1, (on_count >> 8) & 0x0F)
        self._write8(base + 2, off_count & 0xFF)
        self._write8(base + 3, (off_count >> 8) & 0x0F)

    def set_pwm_duty(self, channel: int, duty: float):
        # duty in [0.0, 1.0]
        duty = max(0.0, min(1.0, duty))
        if duty <= 0.0:
            # fully off
            self.set_pwm_raw(channel, 0, 0)
        elif duty >= 1.0:
            # fully on
            self.set_pwm_raw(channel, 0, 4095)
        else:
            off = int(round(duty * 4095))
            off = max(1, min(4094, off))
            self.set_pwm_raw(channel, 0, off)

    def set_pin_digital(self, channel: int, high: bool):
        self.set_pwm_duty(channel, 1.0 if high else 0.0)

def angle_to_duty(angle, freq_hz=50.0):
    MIN_US = 500
    MAX_US = 2500
    angle = max(0, min(180, angle))
    us = MIN_US + (MAX_US - MIN_US) * angle / 180.0
    period_us = 1_000_000.0 / freq_hz
    duty = us / period_us    # fraction of total period
    return duty              # e.g. 0.075 for 7.5%

# ---------- PCA9685 instance ---------- 
#Contains Bus number, I2C address, and frequency in Hz
pca = PCA9685LowLevel(busnum=1, address=0x42, freq_hz=50.0)

# ---------- Jetson Nano Camera GStreamer Pipeline ----------
GST = (
    "nvarguscamerasrc sensor-id=0 !"
    "video/x-raw(memory:NVMM),width=1920,height=1080,framerate=50/1,format=NV12 !"
    "nvvidconv !"
    "video/x-raw,format=BGRx !"
    "videoconvert ! video/x-raw,format=BGR !"
    "appsink drop=true max-buffers=4 sync=false"
)

SERVO_PIN = 22

GPIO.setmode(GPIO.BOARD)            # Sets up Laser GPIO and sets output to LOW
GPIO.setup(SERVO_PIN, GPIO.OUT)
GPIO.output(SERVO_PIN, GPIO.LOW) 

# -------- Model config --------
ENGINE_PATH = "green_specific.engine"   # your TensorRT engine
DEVICE      = 0
IMGSZ       = 704
CONF        = 0.25
HALF        = True

# -------- Load engine (explicit task to silence warning) --------
model = YOLO(ENGINE_PATH, task="detect")

# -------- Camera --------
cap = cv2.VideoCapture(GST, cv2.CAP_GSTREAMER)
if not cap.isOpened():
    raise SystemExit("Failed to open camera.")

WIN = "IMX519 YOLOv8 TensorRT"
cv2.namedWindow(WIN, cv2.WINDOW_AUTOSIZE)

times = collections.deque(maxlen=60)
prev  = time.time()

# ---------- State variables ----------
focuser = Focuser(bus=10)

# State 1 variables
state = 1
focus_pos = 300           
conf_max = 0.0
servo_offset = 0        #Adjust servo offset if needed
acquiring = True
object_detected = False  #Object detection fields
angle = 40
batch_conf = []  

# State 2 variables
focus_positions = list(range(650, 0, -50))  # [750, 700, ..., 50]
current_index = 0
ideal_focus = 300
object_detected_once = False

# State 3 Variables
acquire_tol = 150          # px: stay in sweep until |error| <= this
track_tol   = 10           # px: no movement if within this band (deadband)
direction = 1

# State 4 Variables
past_conf = 0.0
error = .30  
A = 5  # focus step size (change if you want faster/slower focus sweeps)

# State 5 Variables
CENTER_MIN = 0
CENTER_MAX = 180
px_cushion   = 30          # cushion in pixels around image center
slow_step    = 0.5         # degrees per nudge to keep motion slow

# State 6 Variables
laser_toggle_count = 0

#Intialize motors for nav2
sit_down_bitch(1)

#Sets initial servo position
duty = angle_to_duty(angle)
pca.set_pwm_duty(0, duty)

time.sleep(1)

try:
    while True: 

        ok, frame_bgr = cap.read()
        if not ok:
            break

        results = model.predict(
            source=frame_bgr,
            device=DEVICE,
            imgsz=IMGSZ,
            conf=CONF,
            half=HALF,
            verbose=False
        )

        frame_width = frame_bgr.shape[1]  
        center_x = frame_width / 2
        tolerance = 20  

        r = results[0]

        current_time = time.time()

        if (0.1 <= (current_time - prev) < 0.25):
            if len(r.boxes.conf) > 0:
                batch_conf.append(float(r.boxes.conf.max()))
            else:
                batch_conf.append(0.0)

        # top-conf x_center in pixels
        x_center = float(r.boxes.xywh[r.boxes.conf.argmax(), 0]) if len(r.boxes) > 0 else None

        # normalized center for TOY SOLDIER (prefer), else top-conf box
        x_center_n = None
        
        if len(r.boxes) > 0:
            try:
                names = r.names if hasattr(r, "names") else model.names
                cls_ids = r.boxes.cls.cpu().numpy().astype(int)
                xywhn   = r.boxes.xywhn.cpu().numpy()
                confs   = r.boxes.conf.cpu().numpy()

                # try to pick "toy soldier" if present
                target_idx = None
                if names is not None:
                    for i, cid in enumerate(cls_ids):
                        if str(names.get(int(cid), "")).lower() == "toy soldier":
                            if target_idx is None or confs[i] > confs[target_idx]:
                                target_idx = i
                # fallback to highest confidence
                if target_idx is None:
                    target_idx = int(np.argmax(confs))

                x_center_n = float(xywhn[target_idx, 0])  # normalized 0..1
            except Exception:
                if x_center is not None and frame_width > 0:
                    x_center_n = float(x_center / frame_width)

        annotated = results[0].plot()
        cv2.imshow(WIN, annotated)

        # IMPORTANT: let OpenCV process GUI events
        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            break
        
        # ---------- Per-frame state logic ----------
        if state == 1:
            acquiring = True
            if angle > 180:
                angle = 180
                direction = -1              
            elif angle < 40:
                angle = 40
                direction = 1

            # sweep
            angle += 1 * direction

            duty = angle_to_duty(angle + servo_offset)
            pca.set_pwm_duty(0, duty)

            if object_detected:
                state = 2

        if state == 3:
            if x_center is not None:
                error_pixels = center_x - x_center  # + => target left of center

                if acquiring and abs(error_pixels) > acquire_tol:
                    # keep sweeping in the current direction
                    angle += 1 * direction
                else:
                    acquiring = False
                    if abs(error_pixels) > track_tol:
                        state = 4  # switch to fine-tracking state
            else:
                acquiring = True
                angle += 1 * direction
                
            duty = angle_to_duty(angle + servo_offset)
            pca.set_pwm_duty(0, duty)
        
        if state == 5:
            if x_center_n is not None and frame_width > 0:
                margin_n = float(px_cushion) / float(frame_width)
                # nudge slowly toward the center
                if x_center_n < (0.5 - margin_n):
                    angle += slow_step     # target is left in image → turn left
                elif x_center_n > (0.5 + margin_n):
                    angle -= slow_step     # target is right in image → turn right
                # clamp to mechanical limits
                if angle > CENTER_MAX:
                    angle = CENTER_MAX
                elif angle < CENTER_MIN:
                    angle = CENTER_MIN
            # if no detection, just hold current angle
            duty = angle_to_duty(angle + servo_offset)
            pca.set_pwm_duty(0, duty)
        
        # ---------- 0.25 s logic ----------
        if current_time - prev >= .25:
            batch_max_conf = np.mean(batch_conf) if batch_conf else 0.0
            if np.isnan(batch_max_conf) or batch_max_conf < 0.5:
                batch_max_conf = 0.0

            if state == 1:
                if batch_max_conf >= 0.5:
                    focus_pos = 750
                    object_detected = True
                    acquiring = True
                    sit_down_bitch(0)
                    print(f"Object detected with confidence {batch_max_conf:.2f}, switching to state 1→2 for focusing.")
                    state = 2
                    current_index = 0
                    conf_max = 0.0
                    ideal_focus = focus_pos

            if state == 2:  # Autofocus sweep state
                if batch_max_conf >= conf_max:
                    conf_max = batch_max_conf
                    ideal_focus = focus_pos
                    print(f"New ideal focus: {ideal_focus} with conf: {conf_max}")

                # move to next focus position safely
                current_index += 1
                if current_index >= len(focus_positions):
                    # finished full sweep
                    if conf_max < 0.5:
                        object_detected_once = False
                        focus_pos = 300
                        current_index = 0
                        state = 1
                        print("Sweep done, low confidence. Returning to scan.")
                    else:
                        object_detected_once = False
                        focus_pos = ideal_focus
                        print(
                            f"Completed first full sweep after detection. "
                            f"Best focus: {ideal_focus} with conf: {conf_max}"
                        )
                        current_index = 0
                        state = 3
                else:
                    focus_pos = focus_positions[current_index]

            focuser.set(Focuser.OPT_FOCUS, focus_pos)

            if state == 4:
                print(state)
                focus_pos -= A
                if batch_max_conf <= past_conf - 0.01:
                    A = -A
                    print(f"Reversing direction at focus: {focus_pos} with conf: {batch_max_conf}")
                if batch_max_conf < (past_conf - (past_conf * error)):
                    state = 1
                    focus_pos = 300
                    conf_max = 0
                    ideal_focus = 0
                    print(f"Cannot refine focus, returning to scan. Last good conf: {past_conf}")
                if batch_max_conf >= past_conf and batch_max_conf >= 0.5:
                    state = 5
                    print(f"Object in focus with sufficient confidence. Holding focus at: {focus_pos} with conf: {batch_max_conf}")
            
            if state == 5:
                # dwell here some time before firing laser
                laser_toggle_count += 1
                if laser_toggle_count > 16:  # ~4 s at 0.25s per tick
                    laser_toggle_count = 0
                    state = 6

            if state == 6:
                # LASER ON window
                if laser_toggle_count == 0:
                    GPIO.output(SERVO_PIN, GPIO.HIGH)  # turn laser ON once
                laser_toggle_count += 1
                print(6)
                if laser_toggle_count >= 40:  # ~10 s ON time
                    GPIO.output(SERVO_PIN, GPIO.LOW)   # turn laser OFF
                    laser_toggle_count = 0
                    state = 7

            if state == 7:
                # cool-down / re-enable motors, keep laser OFF
                laser_toggle_count += 1
                sit_down_bitch(1)  # re-enable motors
                if laser_toggle_count >= 40:  # ~10 s cool-down
                    focus_pos = 300
                    laser_toggle_count = 0
                    GPIO.output(SERVO_PIN, GPIO.LOW)   # ensure laser stays OFF
                    state = 1
                    conf_max = 0.0
                    acquiring = True
                    object_detected = False
                    angle = 30

            # update past_conf for next tick (used in state 4)
            past_conf = batch_max_conf

            prev = current_time
            batch_conf.clear()

finally:
    cap.release()
    cv2.destroyAllWindows()
```

# `full_on_test.py`
```
# save as full_on_test.py and run: python3 full_on_test.py
import time, Jetson.GPIO as GPIO
ENA, ENB = 15, 32
IN1, IN2, IN3, IN4 = 23, 19, 21, 18  # A side uses IN1/IN2, B side uses IN3/IN4

GPIO.setmode(GPIO.BOARD)
for p in (ENB, ENA, IN1, IN2, IN3, IN4):
    GPIO.setup(p, GPIO.OUT, initial=GPIO.LOW)

# forward both sides
GPIO.output(IN4, GPIO.HIGH); 
GPIO.output(IN3, GPIO.LOW);   # A forward
GPIO.output(IN1, GPIO.LOW); 
GPIO.output(IN2, GPIO.HIGH);   # B forward
GPIO.output(ENB, GPIO.HIGH); 
GPIO.output(ENA, GPIO.HIGH)  # FULL ON

print("Full power for 5s…")
time.sleep(5)

# stop (coast)
GPIO.output(ENA, GPIO.LOW); GPIO.output(ENB, GPIO.LOW)
GPIO.cleanup()
```

# `imu_bno055_smbus.py`
```
#!/usr/bin/env python3
import time, smbus2, rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu

REG_PAGE_ID=0x07; REG_OPR_MODE=0x3D; REG_PWR_MODE=0x3E; REG_UNIT_SEL=0x3B
MODE_CONFIG=0x00; MODE_NDOF=0x0C; PWR_NORMAL=0x00
REG_QUAT_W_LSB=0x20; QUAT_SCALE=1.0/(1<<14)

class BNO055(Node):
    def __init__(self):
        super().__init__('bno055_raw_imu')
        self.declare_parameter('bus', 7)
        self.declare_parameter('address', 0x28)
        self.declare_parameter('frame_id', 'imu_link')
        self.bus_num = int(self.get_parameter('bus').value)
        self.addr    = int(self.get_parameter('address').value)
        self.frame_id= str(self.get_parameter('frame_id').value)
        self.pub = self.create_publisher(Imu, '/imu/raw', 10)
        self.bus = smbus2.SMBus(self.bus_num)
        self._init_bno055()
        self.timer = self.create_timer(0.02, self._tick)

    def _w8(self, r, v): self.bus.write_byte_data(self.addr, r, v)
    def _rn(self, r, n): return self.bus.read_i2c_block_data(self.addr, r, n)

    def _init_bno055(self):
        self._w8(REG_PAGE_ID, 0x00)
        self._w8(REG_OPR_MODE, MODE_CONFIG); time.sleep(0.02)
        self._w8(REG_PWR_MODE, PWR_NORMAL);  time.sleep(0.01)
        self._w8(REG_UNIT_SEL, 0x00);        time.sleep(0.01)
        self._w8(REG_OPR_MODE, MODE_NDOF);   time.sleep(0.05)

    def _tick(self):
        try:
            raw = self._rn(REG_QUAT_W_LSB, 8)
            def s16(lo,hi): v=(hi<<8)|lo; return v-0x10000 if v&0x8000 else v
            w=s16(raw[0],raw[1])*QUAT_SCALE; x=s16(raw[2],raw[3])*QUAT_SCALE
            y=s16(raw[4],raw[5])*QUAT_SCALE; z=s16(raw[6],raw[7])*QUAT_SCALE
            m=Imu(); m.header.stamp=self.get_clock().now().to_msg(); m.header.frame_id=self.frame_id
            m.orientation.w=float(w); m.orientation.x=float(x); m.orientation.y=float(y); m.orientation.z=float(z)
            m.orientation_covariance=[0.02,0.0,0.0, 0.0,0.02,0.0, 0.0,0.0,0.02]
            m.angular_velocity_covariance=[-1.0,0.0,0.0, 0.0,-1.0,0.0, 0.0,0.0,-1.0]
            m.linear_acceleration_covariance=[-1.0,0.0,0.0, 0.0,-1.0,0.0, 0.0,0.0,-1.0]
            self.pub.publish(m)
        except Exception as e:
            self.get_logger().warn(f'I2C read failed: {e}')

def main():
    rclpy.init(); n=BNO055(); rclpy.spin(n); n.destroy_node(); rclpy.shutdown()
if __name__=='__main__': main()
```

# `imu_filter_params.yaml`
```
imu_filter_madgwick:
  ros__parameters:
    use_mag: false
    publish_tf: false
    world_frame: enu
    fixed_frame: imu_link
    # tuning
    gain: 0.1
    zeta: 0.0
    # topics
    imu_frame: imu_link
```

# `imu_node.py`
```
#!/usr/bin/env python3
import time, struct, math
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from sensor_msgs.msg import Imu
from geometry_msgs.msg import Vector3
from smbus2 import SMBus, i2c_msg

# BNO055 registers (page 0)
CHIP_ID        = 0x00  # expect 0xA0
PAGE_ID        = 0x07
OPR_MODE       = 0x3D
PWR_MODE       = 0x3E
SYS_TRIGGER    = 0x3F
UNIT_SEL       = 0x3B

# data registers
GYR_DATA_X_LSB = 0x14
EUL_HEADING_LSB= 0x1A
QUAT_W_LSB     = 0x20
LIN_ACC_X_LSB  = 0x28
TEMP           = 0x34
CALIB_STAT     = 0x35

# modes
MODE_CONFIG = 0x00
MODE_IMU    = 0x08  # accel+gyro fusion
MODE_NDOF   = 0x0C  # full fusion

# scales (datasheet)
LSB_PER_DPS       = 16.0       # gyro raw -> deg/s
LSB_PER_MS2       = 100.0      # lin acc raw -> m/s^2
LSB_PER_EULER_DEG = 16.0       # euler raw -> deg
LSB_PER_QUAT      = 16384.0    # quat raw -> unitless

def _s16(u16):
    return struct.unpack('<h', struct.pack('<H', u16))[0]

class BNO055LowLevel:
    def __init__(self, bus:int, addr:int):
        self.busnum = bus
        self.addr = addr
        self.bus = SMBus(bus)

    def write8(self, reg, val):
        self.bus.write_byte_data(self.addr, reg, val & 0xFF)

    def read8(self, reg):
        return self.bus.read_byte_data(self.addr, reg)

    def read16le(self, reg):
        lo = self.read8(reg)
        hi = self.read8(reg+1)
        return _s16((hi<<8)|lo)

    def read_block(self, reg, length):
        # robust block read using I2C_RDWR
        w = i2c_msg.write(self.addr, [reg])
        r = i2c_msg.read(self.addr, length)
        self.bus.i2c_rdwr(w, r)
        return bytes(r)

    def init(self, mode=MODE_NDOF):
        # wait for chip
        for _ in range(50):
            try:
                if self.read8(CHIP_ID) == 0xA0:
                    break
            except OSError:
                pass
            time.sleep(0.01)
        # to config
        self.write8(OPR_MODE, MODE_CONFIG); time.sleep(0.02)
        # normal power
        self.write8(PWR_MODE, 0x00); time.sleep(0.01)
        # page 0
        self.write8(PAGE_ID, 0x00)
        # units: keep defaults; we convert scaling ourselves
        # start fusion
        self.write8(OPR_MODE, mode); time.sleep(0.02)

    # quaternion (w,x,y,z), unitless
    def read_quat(self):
        b = self.read_block(QUAT_W_LSB, 8)
        w = _s16(b[1]<<8 | b[0]) / LSB_PER_QUAT
        x = _s16(b[3]<<8 | b[2]) / LSB_PER_QUAT
        y = _s16(b[5]<<8 | b[4]) / LSB_PER_QUAT
        z = _s16(b[7]<<8 | b[6]) / LSB_PER_QUAT
        return (w, x, y, z)

    # gyro (rad/s)
    def read_gyro(self):
        b = self.read_block(GYR_DATA_X_LSB, 6)
        gx = _s16(b[1]<<8 | b[0]) / LSB_PER_DPS * (math.pi/180.0)
        gy = _s16(b[3]<<8 | b[2]) / LSB_PER_DPS * (math.pi/180.0)
        gz = _s16(b[5]<<8 | b[4]) / LSB_PER_DPS * (math.pi/180.0)
        return (gx, gy, gz)

    # linear acceleration (m/s^2)
    def read_lin_acc(self):
        b = self.read_block(LIN_ACC_X_LSB, 6)
        ax = _s16(b[1]<<8 | b[0]) / LSB_PER_MS2
        ay = _s16(b[3]<<8 | b[2]) / LSB_PER_MS2
        az = _s16(b[5]<<8 | b[4]) / LSB_PER_MS2
        return (ax, ay, az)

    def alive(self):
        try:
            _ = self.read8(TEMP)
            return True
        except OSError:
            return False

class ImuNode(Node):
    def __init__(self):
        super().__init__('imu_node')
        qos = QoSProfile(reliability=ReliabilityPolicy.BEST_EFFORT,
                         history=HistoryPolicy.KEEP_LAST, depth=20)

        self.declare_parameter('address', 0x28)  # 0x28 = 40
        self.declare_parameter('bus', 1)         # /dev/i2c-1 by default

        self.addr = int(self.get_parameter('address').value)
        self.busnum = int(self.get_parameter('bus').value)

        self.pub_imu = self.create_publisher(Imu, '/imu/raw', qos)
        self.pub_vel = self.create_publisher(Vector3, '/imu/velocity', qos)

        self.bno = BNO055LowLevel(self.busnum, self.addr)
        self.bno.init(MODE_NDOF)
        self.get_logger().info(f'BNO055 init on /dev/i2c-{self.busnum}, addr 0x{self.addr:02x}')

        self.prev_t = time.time()
        self.velocity = [0.0, 0.0, 0.0]
        self.prev_accel = [0.0, 0.0, 0.0]
        self.alpha = 0.8

        self.timer = self.create_timer(0.01, self.loop)  # 100 Hz

    def loop(self):
        if not self.bno.alive():
            return

        t = time.time()
        dt = t - self.prev_t
        if dt <= 0.0:
            return
        self.prev_t = t

        msg = Imu()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'imu_link'

        # orientation from quaternion
        try:
            w,x,y,z = self.bno.read_quat()
            msg.orientation.w = float(w)
            msg.orientation.x = float(x)
            msg.orientation.y = float(y)
            msg.orientation.z = float(z)
            msg.orientation_covariance = [
                0.02, 0.0, 0.0,
                0.0, 0.02, 0.0,
                0.0, 0.0, 0.02,
            ]
        except OSError:
            pass

        # angular velocity
        try:
            gx,gy,gz = self.bno.read_gyro()
            msg.angular_velocity.x = float(gx)
            msg.angular_velocity.y = float(gy)
            msg.angular_velocity.z = float(gz)
            msg.angular_velocity_covariance = [
                0.02, 0.0, 0.0,
                0.0, 0.02, 0.0,
                0.0, 0.0, 0.02,
            ]
        except OSError:
            pass

        # linear accel and integrate velocity
        try:
            ax,ay,az = self.bno.read_lin_acc()
            msg.linear_acceleration.x = float(ax)
            msg.linear_acceleration.y = float(ay)
            msg.linear_acceleration.z = float(az)
            msg.linear_acceleration_covariance = [
                0.5, 0.0, 0.0,
                0.0, 0.5, 0.0,
                0.0, 0.0, 0.5,
            ]

            fa = [
                self.alpha*ax + (1.0-self.alpha)*self.prev_accel[0],
                self.alpha*ay + (1.0-self.alpha)*self.prev_accel[1],
                self.alpha*az + (1.0-self.alpha)*self.prev_accel[2],
            ]
            self.prev_accel = fa
            for i in range(3):
                self.velocity[i] += fa[i]*dt
                if abs(self.velocity[i]) > 10.0:
                    self.velocity[i] = 0.0

            v = Vector3()
            v.x, v.y, v.z = map(float, self.velocity)
            self.pub_vel.publish(v)
        except OSError:
            pass

        self.pub_imu.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    node = ImuNode()
    try:
        rclpy.spin(node)
    finally:
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

# `jetson_imx519_cuda_autofocus (2).py`
```
#!/usr/bin/env python3
# jetson_imx519_cuda_autofocus.py
# Clean-room autofocus implementation for IMX519 + AK7375 on Jetson (Orin Nano, etc.).
# Capture path: GStreamer nvarguscamerasrc -> OpenCV. Focus metric: PyTorch CUDA.
# Lens control: V4L2 focus_absolute on /dev/v4l-subdev* via v4l2-ctl.
#
# Notes:
# - Requires: OpenCV with GStreamer, PyTorch with CUDA, v4l2-ctl installed.
# - This does not copy vendor code. It reimplements standard contrast-AF patterns.
# - Tune steps and timing for your module.
#
# Usage examples:
#   python3 jetson_imx519_cuda_autofocus.py --sensor-id 0 --width 1280 --height 720
#   python3 jetson_imx519_cuda_autofocus.py --focuser /dev/v4l-subdev2 --burst-period 1.0
#
# MIT License (for this script).

import argparse
import subprocess
import sys
import time
import re
from typing import Tuple, Optional

import cv2
import numpy as np
import torch
import torch.nn.functional as F

def check_cuda():
    if not torch.cuda.is_available():
        raise RuntimeError("CUDA not available. Install JetPack PyTorch or enable CUDA.")
    torch.zeros(1, device='cuda')  # warmup

# ------------------------
# Focuser via V4L2 controls
# ------------------------

class V4L2Focuser:
    def __init__(self, device: Optional[str] = None, min_pos: Optional[int] = None,
                 max_pos: Optional[int] = None, settle_ms: int = 30):
        self.device = device or self._probe_device()
        self.min_pos, self.max_pos, self.step = self._read_focus_range() if (min_pos is None or max_pos is None) else (min_pos, max_pos, 1)
        self.settle_ms = settle_ms
        self.current_pos = self.get_focus()  # may fail; ignore errors

    def _probe_device(self) -> str:
        # Find a subdev that exposes focus_absolute control.
        for n in range(0, 16):
            dev = f"/dev/v4l-subdev{n}"
            try:
                out = subprocess.check_output(["v4l2-ctl", "-d", dev, "-l"], stderr=subprocess.STDOUT, text=True)
                if "focus_absolute" in out:
                    return dev
            except subprocess.CalledProcessError:
                continue
        raise RuntimeError("No focuser subdevice with focus_absolute found in /dev/v4l-subdev*. Specify --focuser explicitly.")

    def _read_focus_range(self) -> Tuple[int, int, int]:
        out = subprocess.check_output(["v4l2-ctl", "-d", self.device, "-l"], stderr=subprocess.STDOUT, text=True)
        # Example line: focus_absolute 0x009a090a (int) : min=0 max=1023 step=1 default=0 value=100
        m = re.search(r"focus_absolute.*min=(\d+)\s+max=(\d+)\s+step=(\d+)", out)
        if not m:
            # Fallback to typical AK7375 range
            return (0, 1023, 1)
        return (int(m.group(1)), int(m.group(2)), int(m.group(3)))

    def set_focus(self, pos: int):
        pos = int(max(self.min_pos, min(self.max_pos, pos)))
        try:
            subprocess.check_call(["v4l2-ctl", "-d", self.device, "--set-ctrl", f"focus_absolute={pos}"],
                                  stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.current_pos = pos
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Failed to set focus to {pos} on {self.device}: {e}")
        if self.settle_ms > 0:
            time.sleep(self.settle_ms / 1000.0)

    def get_focus(self) -> Optional[int]:
        try:
            out = subprocess.check_output(["v4l2-ctl", "-d", self.device, "-C", "focus_absolute"],
                                          stderr=subprocess.STDOUT, text=True)
            m = re.search(r"focus_absolute:\s*(\d+)", out)
            if m:
                return int(m.group(1))
        except subprocess.CalledProcessError:
            pass
        return None

# ------------------------
# Camera via GStreamer
# ------------------------

def build_gst_pipeline(sensor_id:int, width:int, height:int, fps:int, exposure_time_us:int=None, gain:int=None) -> str:
    # nvarguscamerasrc yields NV12 in NVMM. We convert to BGR for OpenCV.
    # You can add exposure/gain controls through camera properties if supported.
    caps_nvmm = f"video/x-raw(memory:NVMM), width={width}, height={height}, format=NV12, framerate={fps}/1"
    pipeline = (
        f"nvarguscamerasrc sensor-id={sensor_id} ! "
        f"{caps_nvmm} ! "
        f"nvvidconv ! video/x-raw, format=BGRx ! "
        f"videoconvert ! video/x-raw, format=BGR ! "
        f"appsink drop=true sync=false"
    )
    return pipeline

class GStreamerCamera:
    def __init__(self, sensor_id=0, width=1280, height=720, fps=30):
        self.pipeline = build_gst_pipeline(sensor_id, width, height, fps)
        self.cap = cv2.VideoCapture(self.pipeline, cv2.CAP_GSTREAMER)
        if not self.cap.isOpened():
            raise RuntimeError("Failed to open camera with GStreamer. Check sensor-id and Jetson multimedia stack.")
        self.width = width
        self.height = height
        self._warmup()

    def _warmup(self, n=5):
        for _ in range(n):
            self.read()

    def read(self) -> np.ndarray:
        ok, frame = self.cap.read()
        if not ok or frame is None:
            raise RuntimeError("Camera read failed.")
        return frame

    def release(self):
        self.cap.release()

# ------------------------
# CUDA autofocus metric
# ------------------------

def rgb_to_gray_torch(bgr: torch.Tensor) -> torch.Tensor:
    # bgr: BxHxWx3, float32 [0,1]
    # Convert to luma Y' = 0.114*B + 0.587*G + 0.299*R
    b = bgr[..., 0]
    g = bgr[..., 1]
    r = bgr[..., 2]
    y = 0.114 * b + 0.587 * g + 0.299 * r
    return y.unsqueeze(1)  # Bx1xHxW

def laplacian_variance_metric_cuda(frame_bgr_np: np.ndarray, roi: float = 0.6, downscale: int = 2) -> float:
    # Upload to GPU
    img = torch.from_numpy(frame_bgr_np).to(device='cuda', dtype=torch.float32) / 255.0  # HxWx3
    img = img.unsqueeze(0)  # 1xHxWx3
    gray = rgb_to_gray_torch(img)  # 1x1xHxW

    # Downscale to reduce compute
    if downscale > 1:
        h, w = gray.shape[-2:]
        new_h, new_w = h // downscale, w // downscale
        gray = F.interpolate(gray, size=(new_h, new_w), mode='area')

    # Center ROI crop
    _, _, H, W = gray.shape
    rh = int(H * roi)
    rw = int(W * roi)
    y0 = (H - rh) // 2
    x0 = (W - rw) // 2
    gray = gray[:, :, y0:y0+rh, x0:x0+rw]

    # 3x3 Laplacian kernel
    kernel = torch.tensor([[0., 1., 0.],
                           [1., -4., 1.],
                           [0., 1., 0.]], device='cuda', dtype=torch.float32).view(1, 1, 3, 3)
    lap = F.conv2d(gray, kernel, padding=1)
    # Metric: variance of Laplacian (higher is sharper)
    metric = lap.pow(2).mean() - lap.mean().pow(2)
    return float(metric.item())

# ------------------------
# AF strategy: coarse -> fine -> hill-climb
# ------------------------

class Autofocus:
    def __init__(self, focuser: V4L2Focuser, camera: GStreamerCamera,
                 coarse_step: int = 40, fine_step: int = 8, settle_ms: int = 30,
                 window: int = 160, roi: float = 0.6, downscale: int = 2,
                 verbose: bool = True):
        self.focuser = focuser
        self.camera = camera
        self.coarse_step = max(1, coarse_step)
        self.fine_step = max(1, fine_step)
        self.settle_ms = settle_ms
        self.window = window
        self.roi = roi
        self.downscale = downscale
        self.verbose = verbose

    def _measure(self) -> float:
        frame = self.camera.read()
        return laplacian_variance_metric_cuda(frame, roi=self.roi, downscale=self.downscale)

    def _scan(self, start: int, stop: int, step: int) -> Tuple[int, float]:
        best_pos = start
        best_m = -1.0
        direction = 1 if stop >= start else -1
        for pos in range(start, stop + direction, step * direction):
            self.focuser.set_focus(pos)
            time.sleep(self.settle_ms / 1000.0)  # lens settle
            m = self._measure()
            if self.verbose:
                print(f"[scan] pos={pos} metric={m:.6f}")
            if m > best_m:
                best_m, best_pos = m, pos
        return best_pos, best_m

    def _hill_climb(self, start_pos: int, init_metric: float, step: int = 4, max_iters: int = 20) -> Tuple[int, float]:
        best_pos = start_pos
        best_m = init_metric
        pos = start_pos
        last_dir = 0
        for it in range(max_iters):
            # Try both directions, favor last improvement
            candidates = [pos + step, pos - step] if last_dir >= 0 else [pos - step, pos + step]
            improved = False
            for p in candidates:
                p = int(max(self.focuser.min_pos, min(self.focuser.max_pos, p)))
                if p == pos:
                    continue
                self.focuser.set_focus(p)
                time.sleep(self.settle_ms / 1000.0)
                m = self._measure()
                if self.verbose:
                    print(f"[hill] pos={p} metric={m:.6f}")
                if m > best_m * 1.002:  # 0.2% threshold to avoid noise
                    best_m, best_pos, pos, improved = m, p, p, True
                    last_dir = 1 if p > pos else -1
                    break
            if not improved:
                break
        return best_pos, best_m

    def run_burst(self) -> Tuple[int, float]:
        # Coarse scan across full range
        start = self.focuser.min_pos
        stop = self.focuser.max_pos
        best_pos, best_m = self._scan(start, stop, self.coarse_step)
        # Fine scan around best
        fine_start = max(self.focuser.min_pos, best_pos - self.window)
        fine_stop = min(self.focuser.max_pos, best_pos + self.window)
        best_pos, best_m = self._scan(fine_start, fine_stop, self.fine_step)
        # Hill-climb refine
        best_pos, best_m = self._hill_climb(best_pos, best_m, step=max(1, self.fine_step // 2), max_iters=20)
        # Move to final
        self.focuser.set_focus(best_pos)
        if self.verbose:
            print(f"[result] best_pos={best_pos} metric={best_m:.6f}")
        return best_pos, best_m

def main():
    parser = argparse.ArgumentParser(description="CUDA autofocus for IMX519 + AK7375 on Jetson")
    parser.add_argument("--sensor-id", type=int, default=0)
    parser.add_argument("--width", type=int, default=1280)
    parser.add_argument("--height", type=int, default=720)
    parser.add_argument("--fps", type=int, default=30)
    parser.add_argument("--focuser", type=str, default=None, help="Path to /dev/v4l-subdevX with focus control")
    parser.add_argument("--settle-ms", type=int, default=30)
    parser.add_argument("--coarse-step", type=int, default=40)
    parser.add_argument("--fine-step", type=int, default=8)
    parser.add_argument("--window", type=int, default=160)
    parser.add_argument("--roi", type=float, default=0.6)
    parser.add_argument("--downscale", type=int, default=2)
    parser.add_argument("--burst-period", type=float, default=1.0, help="Seconds between AF bursts")
    parser.add_argument("--verbose", action="store_true")
    args = parser.parse_args()

    check_cuda()
    cam = GStreamerCamera(sensor_id=args.sensor_id, 
                          width=args.width, height=args.height, fps=args.fps)
    focuser = V4L2Focuser(device=args.focuser, settle_ms=args.settle_ms)
    af = Autofocus(focuser=focuser, camera=cam, coarse_step=args.coarse_step, fine_step=args.fine_step,
                   settle_ms=args.settle_ms, window=args.window, roi=args.roi, downscale=args.downscale,
                   verbose=args.verbose)

    print(f"Camera opened {args.width}x{args.height}@{args.fps}. Focuser on {focuser.device} range [{focuser.min_pos},{focuser.max_pos}] step {focuser.step}")
    next_time = time.time()
    try:
        while True:
            now = time.time()
            if now >= next_time:
                af.run_burst()
                next_time = now + args.burst_period
            # Drain a frame to keep pipeline alive
            _ = cam.read()
    except KeyboardInterrupt:
        pass
    finally:
        cam.release()

if __name__ == "__main__":
    main()
```

# `keyboard_gpio_drive.py`
```
#!/usr/bin/env python3
import sys, termios, tty, select, time
import Jetson.GPIO as GPIO

# --- PIN MAP (BOARD numbering) ---
ENA = 32   # PWM A
ENB = 15   # PWM B
IN1 = 23   # B side
IN2 = 19
IN3 = 21   # A side
IN4 = 18

PWM_FREQ = 400  # Hz

def getch(timeout=0.05):
    """Read 1 char with timeout (non-blocking-ish)."""
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    ch = None
    try:
        tty.setraw(fd)
        r, _, _ = select.select([sys.stdin], [], [], timeout)
        if r:
            ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return ch

def setup():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setwarnings(False)
    for p in (IN1, IN2, IN3, IN4):
        GPIO.setup(p, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(ENA, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(ENB, GPIO.OUT, initial=GPIO.LOW)
    pa = GPIO.PWM(ENA, PWM_FREQ)
    pb = GPIO.PWM(ENB, PWM_FREQ)
    pa.start(0)
    pb.start(0)
    return pa, pb

def all_low():
    GPIO.output(IN1, GPIO.LOW)
    GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.LOW)

def drive_forward():
    # A side forward: IN4=HIGH, IN2=LOW
    # B side forward: IN3=HIGH, IN1=LOW
    GPIO.output(IN1, GPIO.HIGH);  GPIO.output(IN2, GPIO.HIGH)
    GPIO.output(IN2, GPIO.HIGH);  GPIO.output(IN1, GPIO.HIGH)
    GPIO.output(IN4, GPIO.LOW); GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.LOW); GPIO.output(IN1, GPIO.LOW)

def drive_backward():
    GPIO.output(IN1, GPIO.LOW);  GPIO.output(IN2, GPIO.HIGH)
    GPIO.output(IN2, GPIO.LOW);  GPIO.output(IN1, GPIO.HIGH)
    GPIO.output(IN4, GPIO.HIGH);  GPIO.output(IN2, GPIO.HIGH)
    GPIO.output(IN3, GPIO.HIGH);  GPIO.output(IN1, GPIO.HIGH)

def drive_left():
    # Spin left: left motor back, right motor forward
    GPIO.output(IN4, GPIO.LOW);  GPIO.output(IN2, GPIO.HIGH)  # A backward
    GPIO.output(IN3, GPIO.HIGH); GPIO.output(IN1, GPIO.LOW)   # B forward

def drive_right():
    GPIO.output(IN4, GPIO.HIGH); GPIO.output(IN2, GPIO.LOW)   # A forward
    GPIO.output(IN3, GPIO.LOW);  GPIO.output(IN1, GPIO.HIGH)  # B backward

def stop():
    all_low()

def help_text(speed):
    print(
        "\nManual GPIO drive (WASD / IJKL style):\n"
        "  i : forward        , : backward\n"
        "  j : left           l : right\n"
        "  k : stop\n"
        "  + : speed up       - : slow down\n"
        "  q : quit\n"
        f"Current speed: {speed:.0f}%\n"
    )

def main():
    pa, pb = setup()
    duty = 40.0  # percent
    help_text(duty)
    try:
        while True:
            ch = getch(0.1)
            if ch is None:
                continue

            if ch in ('q', 'Q'):
                stop()
                break
            elif ch in ('i', 'I', 'w', 'W'):
                drive_forward()
            elif ch in (',', '<', 's', 'S', 'k', 'K'):  # ',' like teleop for back; also 's'
                drive_backward()
            elif ch in ('j', 'J', 'a', 'A'):
                drive_left()
            elif ch in ('l', 'L', 'd', 'D'):
                drive_right()
            elif ch in (' ', 'x', 'X'):
                stop()
            elif ch in ('+', '='):
                duty = min(100.0, duty + 10.0)
                print(f"Speed: {duty:.0f}%")
            elif ch in ('-', '_'):
                duty = max(0.0, duty - 10.0)
                print(f"Speed: {duty:.0f}%")
            elif ch in ('h', 'H', '?'):
                help_text(duty)

            # Apply PWM duty every loop
            pa.ChangeDutyCycle(duty)
            pb.ChangeDutyCycle(duty)
    finally:
        try:
            stop()
            pa.stop(); pb.stop()
        except Exception:
            pass
        GPIO.cleanup()

if __name__ == "__main__":
    main()
```

# `lidar_node.py`
```
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from sensor_msgs.msg import LaserScan
import serial
import math

class LidarNode(Node):
    def __init__(self):
        super().__init__('lidar_node')
        qos = QoSProfile(reliability=ReliabilityPolicy.BEST_EFFORT,
                         history=HistoryPolicy.KEEP_LAST, depth=5)
        self.publisher = self.create_publisher(LaserScan, '/scan', qos)

        port = self.declare_parameter('port', '/dev/ttyUSB0').get_parameter_value().string_value
        baud = self.declare_parameter('baud', 115200).get_parameter_value().integer_value
        try:
            self.serial = serial.Serial(port, baud, timeout=0.05)
            self.get_logger().info(f'LIDAR connected on {port} @ {baud}')
        except Exception as e:
            self.get_logger().error(f'Cannot open LIDAR serial: {e}')
            self.serial = None

        self.angle_min = -math.pi
        self.angle_max =  math.pi
        self.angle_increment = 0.01
        self.range_min = 0.15
        self.range_max = 12.0
        self.N = int((self.angle_max - self.angle_min)/self.angle_increment) + 1

        self.timer = self.create_timer(0.1, self.publish_scan)  # 10 Hz

    def publish_scan(self):
        scan = LaserScan()
        scan.header.frame_id = 'laser'
        scan.header.stamp = self.get_clock().now().to_msg()
        scan.angle_min = float(self.angle_min)
        scan.angle_max = float(self.angle_max)
        scan.angle_increment = float(self.angle_increment)
        scan.range_min = float(self.range_min)
        scan.range_max = float(self.range_max)
        # Placeholder data; use sllidar_ros2 driver in launch for real scans
        scan.ranges = [float('nan')] * self.N
        self.publisher.publish(scan)

def main(args=None):
    rclpy.init(args=args)
    node = LidarNode()
    try:
        rclpy.spin(node)
    finally:
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

# `manual_motor_test.py`
```
#!/usr/bin/env python3
# manual_motor_test.py  —  Jetson Orin Nano keyboard teleop for H-bridge
# Uses BOARD numbering. Run with sudo.
import sys, termios, tty, time
import Jetson.GPIO as GPIO

# ==== USER PINS (BOARD numbering) ====
ENA = 15   # PWM enable for Left side (A)
ENB = 32   # PWM enable for Right side (B)
A_IN1 = 19 # Left side input #1  (your IN2)
A_IN2 = 18 # Left side input #2  (your IN4)
B_IN1 = 23 # Right side input #1 (your IN1)
B_IN2 = 21 # Right side input #2 (your IN3)

# If "forward" is backwards on your wiring, flip these:
LEFT_INVERT  = False
RIGHT_INVERT = False

PWM_FREQ_HZ = 500    # Software PWM; keep modest for smoother duty
START_DUTY  = 40     # % duty to begin with (adjust up if motors stall)
STEP_DUTY   = 10     # % step for [ / ]

def getch():
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return ch

def setup():
    GPIO.setwarnings(False)
    GPIO.setmode(GPIO.BOARD)
    for p in (A_IN1, A_IN2, B_IN1, B_IN2, ENA, ENB):
        GPIO.setup(p, GPIO.OUT, initial=GPIO.LOW)
    pwm_left  = GPIO.PWM(ENA, PWM_FREQ_HZ)
    pwm_right = GPIO.PWM(ENB, PWM_FREQ_HZ)
    pwm_left.start(0)
    pwm_right.start(0)
    return pwm_left, pwm_right

def brake():
    # Both inputs HIGH = brake (most L298N-style drivers)
    GPIO.output(A_IN1, GPIO.HIGH); GPIO.output(A_IN2, GPIO.HIGH)
    GPIO.output(B_IN1, GPIO.HIGH); GPIO.output(B_IN2, GPIO.HIGH)

def coast():
    # Both inputs LOW = coast
    GPIO.output(A_IN1, GPIO.LOW); GPIO.output(A_IN2, GPIO.LOW)
    GPIO.output(B_IN1, GPIO.LOW); GPIO.output(B_IN2, GPIO.LOW)

def set_left(dir_fwd: int, duty: int, pwm_left):
    # dir_fwd: +1 forward, -1 backward, 0 stop
    if dir_fwd == 0:
        brake()
        pwm_left.ChangeDutyCycle(0)
        return
    fwd = (dir_fwd > 0)
    if LEFT_INVERT: fwd = not fwd
    if fwd:
        GPIO.output(A_IN1, GPIO.HIGH); GPIO.output(A_IN2, GPIO.LOW)
    else:
        GPIO.output(A_IN1, GPIO.LOW);  GPIO.output(A_IN2, GPIO.HIGH)
    pwm_left.ChangeDutyCycle(max(0, min(100, duty)))

def set_right(dir_fwd: int, duty: int, pwm_right):
    if dir_fwd == 0:
        brake()
        pwm_right.ChangeDutyCycle(0)
        return
    fwd = (dir_fwd > 0)
    if RIGHT_INVERT: fwd = not fwd
    if fwd:
        GPIO.output(B_IN1, GPIO.HIGH); GPIO.output(B_IN2, GPIO.LOW)
    else:
        GPIO.output(B_IN1, GPIO.LOW);  GPIO.output(B_IN2, GPIO.HIGH)
    pwm_right.ChangeDutyCycle(max(0, min(100, duty)))

def stop_all(pwm_left, pwm_right):
    brake()
    pwm_left.ChangeDutyCycle(0)
    pwm_right.ChangeDutyCycle(0)

def print_help(duty):
    print(
        f"""
Keyboard teleop (duty={duty}%):
  w/s  : forward / backward (both)
  a/d  : spin left / spin right (pivot)
  q/e  : arc left / arc right  (L/R 70/40 duty)
  1/2  : LEFT wheel forward/back (solo)
  9/0  : RIGHT wheel forward/back (solo)
  [ / ]: duty - / +
  space: STOP (brake)
  h    : help
  ESC  : quit
"""
    )

def main():
    pwm_left, pwm_right = setup()
    duty = START_DUTY
    print_help(duty)
    print(">>> Press keys… (run with: sudo -E python3 manual_motor_test.py)")

    try:
        while True:
            ch = getch()
            if ch == '\x1b':  # ESC
                break
            elif ch in ('h', 'H'):
                print_help(duty)
            elif ch == ' ':
                stop_all(pwm_left, pwm_right)
                print("STOP")
            elif ch == '[':
                duty = max(0, duty - STEP_DUTY); print(f"duty -> {duty}%")
            elif ch == ']':
                duty = min(100, duty + STEP_DUTY); print(f"duty -> {duty}%")

            # Whole-robot motions
            elif ch in ('w', 'W'):
                set_left(+1, duty, pwm_left); set_right(+1, duty, pwm_right); print("FWD")
            elif ch in ('s', 'S'):
                set_left(-1, duty, pwm_left); set_right(-1, duty, pwm_right); print("BACK")
            elif ch in ('a', 'A'):
                set_left(-1, duty, pwm_left); set_right(+1, duty, pwm_right); print("SPIN LEFT")
            elif ch in ('d', 'D'):
                set_left(+1, duty, pwm_left); set_right(-1, duty, pwm_right); print("SPIN RIGHT")
            elif ch in ('q', 'Q'):
                set_left(+1, max(0, duty), pwm_left)
                set_right(+1, max(0, int(duty*0.6)), pwm_right)
                print("ARC LEFT")
            elif ch in ('e', 'E'):
                set_left(+1, max(0, int(duty*0.6)), pwm_left)
                set_right(+1, max(0, duty), pwm_right)
                print("ARC RIGHT")

            # Individual wheel jog
            elif ch == '1':
                set_left(+1, duty, pwm_left); set_right(0, 0, pwm_right); print("LEFT FWD")
            elif ch == '2':
                set_left(-1, duty, pwm_left); set_right(0, 0, pwm_right); print("LEFT BACK")
            elif ch == '9':
                set_left(0, 0, pwm_left); set_right(+1, duty, pwm_right); print("RIGHT FWD")
            elif ch == '0':
                set_left(0, 0, pwm_left); set_right(-1, duty, pwm_right); print("RIGHT BACK")

            # ignore other keys
    except KeyboardInterrupt:
        pass
    finally:
        stop_all(pwm_left, pwm_right)
        pwm_left.stop(); pwm_right.stop()
        GPIO.cleanup()
        print("Clean exit.")

if __name__ == "__main__":
    main()
```

# `mapping_launch.py`
```
import os

from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, OpaqueFunction
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node


def _bool_from_launch_config(context, launch_config: LaunchConfiguration) -> bool:
    return launch_config.perform(context).lower() in ('1', 'true', 'yes', 'on')


def _build_launch_nodes(context, *args, **kwargs):
    use_internal_lidar = _bool_from_launch_config(context, LaunchConfiguration('use_internal_lidar'))
    use_ekf = _bool_from_launch_config(context, LaunchConfiguration('use_ekf'))

    share_dir = get_package_share_directory('ros2_mapping_project')

    nodes = []

    if use_internal_lidar:
        nodes.append(Node(
            package='ros2_mapping_project', executable='lidar_node',
            name='lidar_node', output='screen'))
    else:
        nodes.append(Node(
            package='sllidar_ros2', executable='sllidar_node',
            name='sllidar_node', output='screen',
            parameters=[{'channel_type': 'serial',
                         'serial_port': '/dev/ttyUSB0',
                         'serial_baudrate': 115200,
                         'frame_id': 'laser',
                         'inverted': False,
                         'angle_compensate': True}]
        ))

    # IMU raw → Madgwick → /imu/data
    nodes.extend([
        Node(package='ros2_mapping_project', executable='imu_node',
             name='imu_node', output='screen'),
        Node(package='imu_filter_madgwick', executable='imu_filter_madgwick_node',
             name='imu_filter',
             parameters=[os.path.join(share_dir, 'imu_filter_params.yaml'),
                         {'use_mag': False, 'publish_tf': False, 'world_frame': 'enu'}],
             remappings=[('/imu/data_raw', '/imu/raw'), ('/imu/data', '/imu/data')])
    ])

    # Encoders (enable when hardware is connected)
    nodes.append(Node(package='ros2_mapping_project', executable='encoders_node',
                      name='encoders_node', output='screen'))

    if use_ekf:
        # EKF: fuse twist + IMU -> /odometry/filtered and TF
        nodes.append(Node(package='robot_localization', executable='ekf_node',
                          name='ekf_filter_node', output='screen',
                          parameters=[os.path.join(share_dir, 'odom_params.yaml')]))

    # Static TFs: adjust offsets to your mounts
    nodes.extend([
        Node(package='tf2_ros', executable='static_transform_publisher',
             arguments=['0.12', '0.0', '0.10', '0', '0', '0', 'base_link', 'laser']),
        Node(package='tf2_ros', executable='static_transform_publisher',
             arguments=['0', '0', '0.05', '0', '0', '0', 'base_link', 'imu_link'])
    ])

    # SLAM toolbox online sync
    slam_params_file = 'slam_params.yaml' if use_ekf else 'slam_params_no_ekf.yaml'
    nodes.append(Node(package='slam_toolbox', executable='sync_slam_toolbox_node',
                      name='slam_toolbox',
                      parameters=[os.path.join(share_dir, slam_params_file)]))

    # RViz
    nodes.append(Node(package='rviz2', executable='rviz2', name='rviz2',
                      arguments=['-d', os.path.join(share_dir, 'slam.rviz')]))

    return nodes


def generate_launch_description():
    return LaunchDescription([
        DeclareLaunchArgument('use_internal_lidar', default_value='false'),
        DeclareLaunchArgument('use_ekf', default_value='true'),
        OpaqueFunction(function=_build_launch_nodes)
    ])
```

# `motor_driver_pca_reg_dual.py`
```
#!/usr/bin/env python3
# Dual-PCA9685 motor driver for /cmd_vel (no GPIO; register-level I2C)
#  - PCA @ 0x41: channels [EnA, In1, In2]  (default 0,1,2)
#  - PCA @ 0x60: channels [EnB, In3, In4]  (default 0,1,2)
# Forward logic (default):
#   Right side (EnA/In1/In2): forward => IN1=1, IN2=0
#   Left  side (EnB/In3/In4): forward => IN3=1, IN4=0
# STOP/coast = inputs LOW (both 0). If brake_on_zero=True, both HIGH.
#
# Notes:
#  - Use strings for I2C addresses ("0x41", "0x60") to avoid ROS param type issues
#  - Use `max_ang_cmd` so wz=max_ang_cmd gives full-power counter-rotation
#  - `min_duty_pct` ensures startup torque; typical 30–40% for DC gear motors
#
# Example:
#   source /opt/ros/humble/setup.bash
#   python3 motor_driver_pca_reg_dual.py --ros-args \
#     -p ena_addr:="'0x41'" -p enb_addr:="'0x60'" \
#     -p ena_channel:=0 -p in1_channel:=1 -p in2_channel:=2 \
#     -p enb_channel:=0 -p in3_channel:=1 -p in4_channel:=2 \
#     -p pwm_freq_hz:=1000.0 -p min_duty_pct:=35.0 \
#     -p max_lin:=0.8 -p max_ang_cmd:=1.2 -p deadband:=0.03 \
#     -p invert_right:=true -p invert_left:=false

import math
import time
import smbus
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from geometry_msgs.msg import Twist

# ---------- PCA9685 low-level ----------
_PCA_MODE1        = 0x00
_PCA_MODE2        = 0x01
_PCA_PRESCALE     = 0xFE
_PCA_LED0_ON_L    = 0x06
# MODE1 bits
_RESTART          = 0x80
_SLEEP            = 0x10
_AI               = 0x20
# MODE2 bits
_OUTDRV           = 0x04  # totem-pole

class PCA9685LowLevel:
    def __init__(self, busnum: int, address: int, freq_hz: float):
        self.bus    = smbus.SMBus(busnum)
        self.addr   = address
        self.freq_hz= float(freq_hz)
        self._init_chip()

    def _write8(self, reg, val):
        self.bus.write_byte_data(self.addr, reg, val & 0xFF)

    def _read8(self, reg):
        return self.bus.read_byte_data(self.addr, reg)

    def _init_chip(self):
        # reset
        self._write8(_PCA_MODE1, 0x00)  # all call off, AI off initially
        self._write8(_PCA_MODE2, _OUTDRV)
        time.sleep(0.005)
        # sleep to set prescale
        oldmode = self._read8(_PCA_MODE1)
        self._write8(_PCA_MODE1, (oldmode | _SLEEP) & 0xFF)
        prescale = int(round(25_000_000.0 / (4096.0 * self.freq_hz) - 1.0))
        prescale = max(3, min(255, prescale))
        self._write8(_PCA_PRESCALE, prescale)
        # wake, auto-increment
        self._write8(_PCA_MODE1, (oldmode & ~_SLEEP) | _AI)
        time.sleep(0.005)
        # restart
        self._write8(_PCA_MODE1, ((self._read8(_PCA_MODE1) | _RESTART) | _AI) & 0xFF)

    def set_pwm_raw(self, channel: int, on_count: int, off_count: int):
        base = _PCA_LED0_ON_L + 4 * channel
        self._write8(base + 0, on_count & 0xFF)
        self._write8(base + 1, (on_count >> 8) & 0x0F)
        self._write8(base + 2, off_count & 0xFF)
        self._write8(base + 3, (off_count >> 8) & 0x0F)

    def set_pwm_duty(self, channel: int, duty: float):
        # duty in [0.0, 1.0]
        duty = max(0.0, min(1.0, duty))
        if duty <= 0.0:
            # fully off
            self.set_pwm_raw(channel, 0, 0)
        elif duty >= 1.0:
            # fully on (use ON=0x1000 trick or set OFF=0)
            self.set_pwm_raw(channel, 0, 4095)
        else:
            off = int(round(duty * 4095))
            off = max(1, min(4094, off))
            self.set_pwm_raw(channel, 0, off)

    def set_pin_digital(self, channel: int, high: bool):
        self.set_pwm_duty(channel, 1.0 if high else 0.0)

# ---------- Helpers ----------
def _clip(x, lo, hi): return lo if x < lo else hi if x > hi else x

# ---------- ROS Node ----------
class MotorDriverPCADual(Node):
    def __init__(self):
        super().__init__('motor_driver_pca_dual')

        # Addresses as STRINGS so CLI -p works cleanly
        self.declare_parameter('ena_addr', '0x41')
        self.declare_parameter('enb_addr', '0x60')

        # Channel mapping (defaults: En*=0, inputs 1&2)
        self.declare_parameter('ena_channel', 0)
        self.declare_parameter('in1_channel', 1)
        self.declare_parameter('in2_channel', 2)

        self.declare_parameter('enb_channel', 0)
        self.declare_parameter('in3_channel', 1)
        self.declare_parameter('in4_channel', 2)

        # Control params
        self.declare_parameter('pwm_freq_hz', 1000.0)
        self.declare_parameter('min_duty_pct', 35.0)   # %
        self.declare_parameter('min_duty_turn_pct', 75.0) # % for turn-in-place
        self.declare_parameter('deadband', 0.03)       # normalized
        self.declare_parameter('max_lin', 0.8)         # m/s (for normalization)
        self.declare_parameter('max_ang_cmd', 1.2)     # rad/s that maps to full turn
        self.declare_parameter('brake_on_zero', False) # if True => both inputs HIGH on zero

        # Side inversion (flip forward)
        self.declare_parameter('invert_right', False)
        self.declare_parameter('invert_left',  False)

        # Which side EnA drives (True=left)
        self.declare_parameter('map_enA_to_left', True)

        # Command topic for Twist messages (teleop/Nav2)
        self.declare_parameter('cmd_topic', '/cmd_vel')

        # I2C bus number (Jetson 40-pin I2C is usually bus 1)
        self.declare_parameter('i2c_bus', 1)

        # Read params
        ena_addr_str = self.get_parameter('ena_addr').get_parameter_value().string_value
        enb_addr_str = self.get_parameter('enb_addr').get_parameter_value().string_value
        self.ena_addr = int(ena_addr_str, 16)
        self.enb_addr = int(enb_addr_str, 16)

        self.ena_ch = int(self.get_parameter('ena_channel').value)
        self.in1_ch = int(self.get_parameter('in1_channel').value)
        self.in2_ch = int(self.get_parameter('in2_channel').value)

        self.enb_ch = int(self.get_parameter('enb_channel').value)
        self.in3_ch = int(self.get_parameter('in3_channel').value)
        self.in4_ch = int(self.get_parameter('in4_channel').value)

        self.freq_hz   = float(self.get_parameter('pwm_freq_hz').value)
        self.min_duty  = float(self.get_parameter('min_duty_pct').value) / 100.0
        self.min_duty_turn = float(self.get_parameter('min_duty_turn_pct').value) / 100.0
        self.deadband  = float(self.get_parameter('deadband').value)
        self.max_lin   = float(self.get_parameter('max_lin').value)
        self.max_ang   = float(self.get_parameter('max_ang_cmd').value)
        self.brake0    = bool(self.get_parameter('brake_on_zero').value)

        self.inv_r     = bool(self.get_parameter('invert_right').value)
        self.inv_l     = bool(self.get_parameter('invert_left').value)
        self.mapA_left = bool(self.get_parameter('map_enA_to_left').value)

        cmd_topic_param = self.get_parameter('cmd_topic').get_parameter_value().string_value
        self.cmd_topic  = cmd_topic_param if cmd_topic_param else '/cmd_vel'

        busnum         = int(self.get_parameter('i2c_bus').value)

        # Init both PCA chips
        self.pcaA = PCA9685LowLevel(busnum, self.ena_addr, self.freq_hz)
        self.pcaB = PCA9685LowLevel(busnum, self.enb_addr, self.freq_hz)

        # Map sides to boards/channels
        if self.mapA_left:
            self.left  = dict(pca=self.pcaA, en=self.ena_ch, fwd=self.in3_ch, rev=self.in4_ch)  # use IN3/IN4 semantics for left
            self.right = dict(pca=self.pcaB, en=self.enb_ch, fwd=self.in1_ch, rev=self.in2_ch)  # use IN1/IN2 semantics for right
        else:
            self.left  = dict(pca=self.pcaB, en=self.enb_ch, fwd=self.in3_ch, rev=self.in4_ch)
            self.right = dict(pca=self.pcaA, en=self.ena_ch, fwd=self.in1_ch, rev=self.in2_ch)

        # Ensure stopped
        self._coast_side(self.left)
        self._coast_side(self.right)

        # Subscriber
        qos = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=10,
        )
        self.sub = self.create_subscription(Twist, self.cmd_topic, self.on_cmd, qos)
        self.get_logger().info(
            f"PCA A=0x{self.ena_addr:02X} (EnA={self.ena_ch}, In1={self.in1_ch}, In2={self.in2_ch}) | "
            f"PCA B=0x{self.enb_addr:02X} (EnB={self.enb_ch}, In3={self.in3_ch}, In4={self.in4_ch}) | "
            f"freq={self.freq_hz}Hz min_duty={self.min_duty*100:.0f}% | listening on '{self.cmd_topic}'"
        )

    # ----- side helpers -----
    def _apply_side(self, side, forward: bool, duty: float, brake: bool):
        pca = side['pca']; en = side['en']; fwd = side['fwd']; rev = side['rev']
        duty = _clip(duty, 0.0, 1.0)

        if duty <= 0.0:
            # STOP
            pca.set_pwm_duty(en, 0.0)
            if self.brake0 or brake:
                pca.set_pin_digital(fwd, True)
                pca.set_pin_digital(rev, True)
            else:
                pca.set_pin_digital(fwd, False)
                pca.set_pin_digital(rev, False)
            return

        # Direction
        if forward:
            pca.set_pin_digital(fwd, True)
            pca.set_pin_digital(rev, False)
        else:
            pca.set_pin_digital(fwd, False)
            pca.set_pin_digital(rev, True)

        # Enable PWM
        pca.set_pwm_duty(en, duty)

    def _coast_side(self, side):
        side['pca'].set_pwm_duty(side['en'], 0.0)
        side['pca'].set_pin_digital(side['fwd'], False)
        side['pca'].set_pin_digital(side['rev'], False)

    # ----- mixer -----
    def on_cmd(self, msg: Twist):
        vx = float(msg.linear.x)
        wz = float(msg.angular.z)

        # Normalize to [-1,1]
        mix_v = _clip(vx / max(1e-6, self.max_lin), -1.0, 1.0)
        mix_w = _clip(wz / max(1e-6, self.max_ang), -1.0, 1.0)

        r = mix_v + mix_w
        l = mix_v - mix_w

        # Keep within [-1,1] preserving ratio
        peak = max(1.0, abs(r), abs(l))
        r /= peak; l /= peak

        # Detect turn-in-place
        is_turn_in_place = abs(vx) < self.deadband and abs(wz) > 0

        def map_duty(x, is_turn):
            ax = abs(x)
            if ax < self.deadband:
                return 0.0, True
            
            min_d = self.min_duty_turn if is_turn else self.min_duty
            return max(min_d, ax), False

        duty_r, off_r = map_duty(r, is_turn_in_place)
        duty_l, off_l = map_duty(l, is_turn_in_place)

        # Apply inversion flags
        dir_r = (r >= 0.0)
        dir_l = (l >= 0.0)
        if self.inv_r: dir_r = not dir_r
        if self.inv_l: dir_l = not dir_l

        # Drive sides
        if off_r:
            self._apply_side(self.right, True, 0.0, brake=False)
        else:
            self._apply_side(self.right, dir_r, duty_r, brake=False)

        if off_l:
            self._apply_side(self.left, True, 0.0, brake=False)
        else:
            self._apply_side(self.left, dir_l, duty_l, brake=False)

    def destroy_node(self):
        try:
            self._coast_side(self.left)
            self._coast_side(self.right)
        finally:
            super().destroy_node()

def main():
    rclpy.init()
    node = MotorDriverPCADual()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()```

# `nav2_fixed.rviz`
```
Panels:
  - Class: rviz_common/Displays
    Help Height: 0
    Name: Displays
    Property Tree Widget:
      Expanded:
        - /Global Options1
        - /TF1/Frames1
        - /TF1/Tree1
      Splitter Ratio: 0.5833333134651184
    Tree Height: 606
  - Class: rviz_common/Selection
    Name: Selection
  - Class: rviz_common/Tool Properties
    Expanded:
      - /Publish Point1
    Name: Tool Properties
    Splitter Ratio: 0.5886790156364441
  - Class: rviz_common/Views
    Expanded:
      - /Current View1
    Name: Views
    Splitter Ratio: 0.5
  - Class: nav2_rviz_plugins/Navigation 2
    Name: Navigation 2
Visualization Manager:
  Class: ""
  Displays:
    - Alpha: 0.5
      Cell Size: 1
      Class: rviz_default_plugins/Grid
      Color: 160; 160; 164
      Enabled: true
      Line Style:
        Line Width: 0.029999999329447746
        Value: Lines
      Name: Grid
      Normal Cell Count: 0
      Offset:
        X: 0
        Y: 0
        Z: 0
      Plane: XY
      Plane Cell Count: 10
      Reference Frame: <Fixed Frame>
      Value: true
    - Alpha: 1
      Class: rviz_default_plugins/RobotModel
      Collision Enabled: false
      Description File: ""
      Description Source: Topic
      Description Topic:
        Depth: 5
        Durability Policy: Volatile
        History Policy: Keep Last
        Reliability Policy: Reliable
        Value: /robot_description
      Enabled: false
      Links:
        All Links Enabled: true
        Expand Joint Details: false
        Expand Link Details: false
        Expand Tree: false
        Link Tree Style: ""
      Mass Properties:
        Inertia: false
        Mass: false
      Name: RobotModel
      TF Prefix: ""
      Update Interval: 0
      Value: false
      Visual Enabled: true
    - Class: rviz_default_plugins/TF
      Enabled: true
      Frame Timeout: 15
      Frames:
        All Enabled: false
        base_footprint:
          Value: true
        base_link:
          Value: true
        base_scan:
          Value: true
        camera_depth_frame:
          Value: true
        camera_depth_optical_frame:
          Value: true
        camera_link:
          Value: true
        camera_rgb_frame:
          Value: true
        camera_rgb_optical_frame:
          Value: true
        caster_back_left_link:
          Value: true
        caster_back_right_link:
          Value: true
        imu_link:
          Value: true
        map:
          Value: true
        odom:
          Value: true
        wheel_left_link:
          Value: true
        wheel_right_link:
          Value: true
      Marker Scale: 1
      Name: TF
      Show Arrows: true
      Show Axes: true
      Show Names: false
      Tree:
        map:
          odom:
            base_footprint:
              base_link:
                base_scan:
                  {}
                camera_link:
                  camera_depth_frame:
                    camera_depth_optical_frame:
                      {}
                  camera_rgb_frame:
                    camera_rgb_optical_frame:
                      {}
                caster_back_left_link:
                  {}
                caster_back_right_link:
                  {}
                imu_link:
                  {}
                wheel_left_link:
                  {}
                wheel_right_link:
                  {}
      Update Interval: 0
      Value: true
    - Alpha: 1
      Autocompute Intensity Bounds: true
      Autocompute Value Bounds:
        Max Value: 10
        Min Value: -10
        Value: true
      Axis: Z
      Channel Name: intensity
      Class: rviz_default_plugins/LaserScan
      Color: 255; 255; 255
      Color Transformer: Intensity
      Decay Time: 0
      Enabled: true
      Invert Rainbow: false
      Max Color: 255; 255; 255
      Max Intensity: 0
      Min Color: 0; 0; 0
      Min Intensity: 0
      Name: LaserScan
      Position Transformer: XYZ
      Selectable: true
      Size (Pixels): 3
      Size (m): 0.009999999776482582
      Style: Points
      Topic:
        Depth: 5
        Durability Policy: Volatile
        Filter size: 10
        History Policy: Keep Last
        Reliability Policy: Best Effort
        Value: /scan
      Use Fixed Frame: true
      Use rainbow: true
      Value: true
    - Alpha: 1
      Autocompute Intensity Bounds: true
      Autocompute Value Bounds:
        Max Value: 10
        Min Value: -10
        Value: true
      Axis: Z
      Channel Name: intensity
      Class: rviz_default_plugins/PointCloud2
      Color: 255; 255; 255
      Color Transformer: ""
      Decay Time: 0
      Enabled: true
      Invert Rainbow: false
      Max Color: 255; 255; 255
      Max Intensity: 4096
      Min Color: 0; 0; 0
      Min Intensity: 0
      Name: Bumper Hit
      Position Transformer: ""
      Selectable: true
      Size (Pixels): 3
      Size (m): 0.07999999821186066
      Style: Spheres
      Topic:
        Depth: 5
        Durability Policy: Volatile
        Filter size: 10
        History Policy: Keep Last
        Reliability Policy: Best Effort
        Value: /mobile_base/sensors/bumper_pointcloud
      Use Fixed Frame: true
      Use rainbow: true
      Value: true
    - Alpha: 1
      Class: rviz_default_plugins/Map
      Color Scheme: map
      Draw Behind: true
      Enabled: true
      Name: Map
      Topic:
        Depth: 1
        Durability Policy: Transient Local
        History Policy: Keep Last
        Reliability Policy: Reliable
        Value: /map
      Use Timestamp: false
      Value: true
    - Alpha: 1
      Class: nav2_rviz_plugins/ParticleCloud
      Color: 0; 180; 0
      Enabled: true
      Max Arrow Length: 0.3
      Min Arrow Length: 0.02
      Name: Amcl Particle Swarm
      Shape: Arrow (Flat)
      Topic:
        Depth: 5
        Durability Policy: Volatile
        History Policy: Keep Last
        Reliability Policy: Best Effort
        Value: /particle_cloud
      Value: true
    - Class: rviz_common/Group
      Displays:
        - Alpha: 0.3
          Class: rviz_default_plugins/Map
          Color Scheme: costmap
          Draw Behind: false
          Enabled: true
          Name: Global Costmap
          Topic:
            Depth: 1
            Durability Policy: Transient Local
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /global_costmap/costmap
          Use Timestamp: false
          Value: true
        - Alpha: 0.3
          Class: rviz_default_plugins/Map
          Color Scheme: costmap
          Draw Behind: false
          Enabled: true
          Name: Downsampled Costmap
          Topic:
            Depth: 1
            Durability Policy: Transient Local
            Filter size: 10
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /downsampled_costmap
          Update Topic:
            Depth: 5
            Durability Policy: Volatile
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /downsampled_costmap_updates
          Use Timestamp: false
          Value: true
        - Alpha: 1
          Buffer Length: 1
          Class: rviz_default_plugins/Path
          Color: 255; 0; 0
          Enabled: true
          Head Diameter: 0.019999999552965164
          Head Length: 0.019999999552965164
          Length: 0.30000001192092896
          Line Style: Lines
          Line Width: 0.029999999329447746
          Name: Path
          Offset:
            X: 0
            Y: 0
            Z: 0
          Pose Color: 255; 85; 255
          Pose Style: Arrows
          Radius: 0.029999999329447746
          Shaft Diameter: 0.004999999888241291
          Shaft Length: 0.019999999552965164
          Topic:
            Depth: 5
            Durability Policy: Volatile
            Filter size: 10
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /plan
          Value: true
        - Alpha: 1
          Autocompute Intensity Bounds: true
          Autocompute Value Bounds:
            Max Value: 10
            Min Value: -10
            Value: true
          Axis: Z
          Channel Name: intensity
          Class: rviz_default_plugins/PointCloud2
          Color: 125; 125; 125
          Color Transformer: FlatColor
          Decay Time: 0
          Enabled: true
          Invert Rainbow: false
          Max Color: 255; 255; 255
          Max Intensity: 4096
          Min Color: 0; 0; 0
          Min Intensity: 0
          Name: VoxelGrid
          Position Transformer: XYZ
          Selectable: true
          Size (Pixels): 3
          Size (m): 0.05000000074505806
          Style: Boxes
          Topic:
            Depth: 5
            Durability Policy: Volatile
            Filter size: 10
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /global_costmap/voxel_marked_cloud
          Use Fixed Frame: true
          Use rainbow: true
          Value: true
        - Alpha: 1
          Class: rviz_default_plugins/Polygon
          Color: 25; 255; 0
          Enabled: false
          Name: Polygon
          Topic:
            Depth: 5
            Durability Policy: Volatile
            Filter size: 10
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /global_costmap/published_footprint
          Value: false
      Enabled: true
      Name: Global Planner
    - Class: rviz_common/Group
      Displays:
        - Alpha: 0.699999988079071
          Class: rviz_default_plugins/Map
          Color Scheme: costmap
          Draw Behind: false
          Enabled: true
          Name: Local Costmap
          Topic:
            Depth: 1
            Durability Policy: Transient Local
            Filter size: 10
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /local_costmap/costmap
          Update Topic:
            Depth: 5
            Durability Policy: Volatile
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /local_costmap/costmap_updates
          Use Timestamp: false
          Value: true
        - Alpha: 1
          Buffer Length: 1
          Class: rviz_default_plugins/Path
          Color: 0; 12; 255
          Enabled: true
          Head Diameter: 0.30000001192092896
          Head Length: 0.20000000298023224
          Length: 0.30000001192092896
          Line Style: Lines
          Line Width: 0.029999999329447746
          Name: Local Plan
          Offset:
            X: 0
            Y: 0
            Z: 0
          Pose Color: 255; 85; 255
          Pose Style: None
          Radius: 0.029999999329447746
          Shaft Diameter: 0.10000000149011612
          Shaft Length: 0.10000000149011612
          Topic:
            Depth: 5
            Durability Policy: Volatile
            Filter size: 10
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /local_plan
          Value: true
        - Class: rviz_default_plugins/MarkerArray
          Enabled: false
          Name: Trajectories
          Namespaces:
            {}
          Topic:
            Depth: 5
            Durability Policy: Volatile
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /marker
          Value: false
        - Alpha: 1
          Class: rviz_default_plugins/Polygon
          Color: 25; 255; 0
          Enabled: true
          Name: Polygon
          Topic:
            Depth: 5
            Durability Policy: Volatile
            Filter size: 10
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /local_costmap/published_footprint
          Value: true
        - Alpha: 1
          Autocompute Intensity Bounds: true
          Autocompute Value Bounds:
            Max Value: 10
            Min Value: -10
            Value: true
          Axis: Z
          Channel Name: intensity
          Class: rviz_default_plugins/PointCloud2
          Color: 255; 255; 255
          Color Transformer: RGB8
          Decay Time: 0
          Enabled: true
          Invert Rainbow: false
          Max Color: 255; 255; 255
          Max Intensity: 4096
          Min Color: 0; 0; 0
          Min Intensity: 0
          Name: VoxelGrid
          Position Transformer: XYZ
          Selectable: true
          Size (Pixels): 3
          Size (m): 0.009999999776482582
          Style: Flat Squares
          Topic:
            Depth: 5
            Durability Policy: Volatile
            Filter size: 10
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /local_costmap/voxel_marked_cloud
          Use Fixed Frame: true
          Use rainbow: true
          Value: true
      Enabled: true
      Name: Controller
    - Class: rviz_common/Group
      Displays:
        - Class: rviz_default_plugins/Image
          Enabled: true
          Max Value: 1
          Median window: 5
          Min Value: 0
          Name: RealsenseCamera
          Normalize Range: true
          Topic:
            Depth: 5
            Durability Policy: Volatile
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /intel_realsense_r200_depth/image_raw
          Value: true
        - Alpha: 1
          Autocompute Intensity Bounds: true
          Autocompute Value Bounds:
            Max Value: 10
            Min Value: -10
            Value: true
          Axis: Z
          Channel Name: intensity
          Class: rviz_default_plugins/PointCloud2
          Color: 255; 255; 255
          Color Transformer: RGB8
          Decay Time: 0
          Enabled: true
          Invert Rainbow: false
          Max Color: 255; 255; 255
          Max Intensity: 4096
          Min Color: 0; 0; 0
          Min Intensity: 0
          Name: RealsenseDepthImage
          Position Transformer: XYZ
          Selectable: true
          Size (Pixels): 3
          Size (m): 0.009999999776482582
          Style: Flat Squares
          Topic:
            Depth: 5
            Durability Policy: Volatile
            Filter size: 10
            History Policy: Keep Last
            Reliability Policy: Reliable
            Value: /intel_realsense_r200_depth/points
          Use Fixed Frame: true
          Use rainbow: true
          Value: true
      Enabled: false
      Name: Realsense
    - Class: rviz_default_plugins/MarkerArray
      Enabled: true
      Name: MarkerArray
      Namespaces:
        {}
      Topic:
        Depth: 5
        Durability Policy: Volatile
        History Policy: Keep Last
        Reliability Policy: Reliable
        Value: /waypoints
      Value: true
  Enabled: true
  Global Options:
    Background Color: 48; 48; 48
    Fixed Frame: map
    Frame Rate: 30
  Name: root
  Tools:
    - Class: rviz_default_plugins/MoveCamera
    - Class: rviz_default_plugins/Select
    - Class: rviz_default_plugins/FocusCamera
    - Class: rviz_default_plugins/Measure
      Line color: 128; 128; 0
    - Class: rviz_default_plugins/SetInitialPose
      Covariance x: 0.25
      Covariance y: 0.25
      Covariance yaw: 0.06853891909122467
      Topic:
        Depth: 5
        Durability Policy: Volatile
        History Policy: Keep Last
        Reliability Policy: Reliable
        Value: /initialpose
    - Class: rviz_default_plugins/PublishPoint
      Single click: true
      Topic:
        Depth: 5
        Durability Policy: Volatile
        History Policy: Keep Last
        Reliability Policy: Reliable
        Value: /clicked_point
    - Class: nav2_rviz_plugins/GoalTool
  Transformation:
    Current:
      Class: rviz_default_plugins/TF
  Value: true
  Views:
    Current:
      Angle: -1.5708
      Class: rviz_default_plugins/TopDownOrtho
      Enable Stereo Rendering:
        Stereo Eye Separation: 0.05999999865889549
        Stereo Focal Distance: 1
        Swap Stereo Eyes: false
        Value: false
      Invert Z Axis: false
      Name: Current View
      Near Clip Distance: 0.009999999776482582
      Scale: 160
      Target Frame: <Fixed Frame>
      Value: TopDownOrtho (rviz_default_plugins)
      X: 0
      Y: 0
    Saved: ~
Window Geometry:
  Displays:
    collapsed: false
  Height: 932
  Hide Left Dock: false
  Hide Right Dock: true
  Navigation 2:
    collapsed: false
  QMainWindow State: 000000ff00000000fd00000004000000000000016a0000034afc020000000afb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003d0000029b000000c900fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb00000018004e0061007600690067006100740069006f006e0020003201000002de000000a90000008100fffffffb0000001e005200650061006c00730065006e0073006500430061006d00650072006100000002c6000000c10000002800ffffff000000010000010f0000034afc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073000000003d0000034a000000a400fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000004420000003efc0100000002fb0000000800540069006d00650100000000000004420000000000000000fb0000000800540069006d00650100000000000004500000000000000000000004990000034a00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
  RealsenseCamera:
    collapsed: false
  Selection:
    collapsed: false
  Tool Properties:
    collapsed: false
  Views:
    collapsed: true
  Width: 1545
  X: 696
  Y: 229
```

# `nav2_min.yaml`
```
amcl:
  ros__parameters:
    use_map_topic: true
    scan_topic: scan

map_server:
  ros__parameters:
    use_sim_time: false
    yaml_filename: ""

planner_server:
  ros__parameters:
    use_sim_time: false
    expected_planner_frequency: 20.0
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_smac_planner/SmacPlanner2D"
      use_astar: true

controller_server:
  ros__parameters:
    use_sim_time: false
    controller_frequency: 10.0
    controller_plugins: ["FollowPath"]
    FollowPath:
      plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"

bt_navigator:
  ros__parameters:
    use_sim_time: false
    global_frame: map
    robot_base_frame: base_link
    transform_tolerance: 0.2
    goal_reached_tol: 0.05

    # IMPORTANT: override the default BT XMLs
    default_nav_to_pose_bt_xml: "/home/team4/Desktop/ros2_mapping_project/simple_nav.xml"
    default_nav_through_poses_bt_xml: "/home/team4/Desktop/ros2_mapping_project/simple_nav.xml"

    plugin_lib_names:
      - nav2_compute_path_to_pose_action_bt_node
      - nav2_compute_path_through_poses_action_bt_node
      - nav2_follow_path_action_bt_node
      - nav2_goal_reached_condition_bt_node
      - nav2_is_path_valid_condition_bt_node
      - nav2_distance_traveled_condition_bt_node
      - nav2_rate_controller_bt_node
      - nav2_speed_controller_bt_node
      - nav2_truncate_path_action_bt_node
      - nav2_clear_costmap_service_bt_node
      - nav2_reinitialize_global_localization_service_bt_node
      - nav2_remove_passed_goals_action_bt_node
      - nav2_back_up_action_bt_node
      - nav2_spin_action_bt_node
      - nav2_wait_action_bt_node

behavior_server:
  ros__parameters:
    use_sim_time: false

smoother_server:
  ros__parameters:
    use_sim_time: false

waypoint_follower:
  ros__parameters:
    use_sim_time: false

velocity_smoother:
  ros__parameters:
    use_sim_time: false

global_costmap:
  ros__parameters:
    use_sim_time: false
    global_frame: map
    robot_base_frame: base_link

local_costmap:
  ros__parameters:
    use_sim_time: false
    global_frame: odom
    robot_base_frame: base_link
```

# `nav2_params.yaml`
```
amcl:
  ros__parameters:
    use_sim_time: false
    alpha1: 0.2
    alpha2: 0.2
    alpha3: 0.2
    alpha4: 0.2
    alpha5: 0.2
    base_frame_id: "base_link"
    beam_skip_distance: 0.5
    beam_skip_error_threshold: 0.9
    beam_skip_threshold: 0.3
    do_beamskip: false
    global_frame_id: "map"
    lambda_short: 0.1
    laser_likelihood_max_dist: 2.0
    laser_max_range: 10.0
    laser_min_range: 0.1
    laser_model_type: "likelihood_field"
    max_beams: 60
    max_particles: 2000
    min_particles: 500
    odom_frame_id: "odom"
    pf_err: 0.05
    pf_z: 0.99
    recovery_alpha_fast: 0.0
    recovery_alpha_slow: 0.0
    resample_interval: 1
    robot_model_type: "diff"
    scan_topic: "scan"
    tf_broadcast: true
    transform_tolerance: 1.0
    update_min_a: 0.1
    update_min_d: 0.1
    z_hit: 0.5
    z_max: 0.05
    z_rand: 0.5
    z_short: 0.05

map_server:
  ros__parameters:
    use_sim_time: false
    yaml_filename: ""
    frame_id: "map"
    topic_name: "map"
    use_pose: false

###############################################################################
# Planner server
###############################################################################
planner_server:
  ros__parameters:
    use_sim_time: false
    expected_planner_frequency: 20.0
    planner_plugins: ["GridBased"]

    GridBased:
      plugin: "nav2_smac_planner/SmacPlanner2D"
      tolerance: 0.12
      downsample_costmap: false
      allow_unknown: true
      max_iterations: 1000000
      max_on_approach_iterations: 1000
      motion_model_for_search: "Dubin"
      angle_quantization_bins: 72
      minimum_turning_radius: 0.25
      cost_travel_multiplier: 2.0
      debug_visualizations: false

###############################################################################
# Controller server
###############################################################################
controller_server:
  ros__parameters:
    use_sim_time: false
    controller_frequency: 10.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.001

    progress_checker_plugins: ["progress_checker"]
    goal_checker_plugins: ["goal_checker"]
    controller_plugins: ["FollowPath"]

    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.10
      movement_time_allowance: 10.0

    goal_checker:
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.08
      yaw_goal_tolerance: 0.15
      stateful: true

    FollowPath:
      plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"
      desired_linear_vel: 0.4
      min_linear_vel: 0.05
      max_angular_vel: 1.5
      min_angular_vel: 0.4
      lookahead_dist: 0.6
      min_lookahead_dist: 0.3
      max_lookahead_dist: 0.8
      lookahead_time: 1.5
      rotate_to_heading_angular_vel: 1.0
      transform_tolerance: 0.2
      use_velocity_scaled_lookahead_dist: true
      use_cost_regulated_linear_velocity_scaling: true
      regulated_linear_scaling_min_radius: 0.9
      regulated_linear_scaling_min_speed: 0.05
      use_collision_detection: true
      max_allowed_time_to_collision_up_to_carrot: 1.0
      use_rotate_to_heading: true
      rotate_to_heading_min_angle: 0.785

###############################################################################
# BT Navigator
###############################################################################
bt_navigator:
  ros__parameters:
    use_sim_time: false
    global_frame: "map"
    robot_base_frame: "base_link"
    odom_topic: "odom"
    transform_tolerance: 0.2
    default_server_timeout: 30
    wait_for_service_timeout: 5
    bt_loop_duration: 10
    goal_reached_tol: 0.05

    # Use your simple tree for both single-goal and multi-goal
    default_nav_to_pose_bt_xml: "/home/team4/Desktop/ros2_mapping_project/simple_nav.xml"
    default_nav_through_poses_bt_xml: "/home/team4/Desktop/ros2_mapping_project/simple_nav.xml"

    plugin_lib_names:
      - nav2_compute_path_to_pose_action_bt_node
      - nav2_compute_path_through_poses_action_bt_node
      - nav2_follow_path_action_bt_node
      - nav2_goal_reached_condition_bt_node
      - nav2_is_path_valid_condition_bt_node
      - nav2_clear_costmap_service_bt_node
      - nav2_distance_traveled_condition_bt_node
      - nav2_rate_controller_bt_node
      - nav2_speed_controller_bt_node
      - nav2_truncate_path_action_bt_node
      - nav2_reinitialize_global_localization_service_bt_node
      - nav2_remove_passed_goals_action_bt_node
      - nav2_back_up_action_bt_node
      - nav2_spin_action_bt_node
      - nav2_wait_action_bt_node

###############################################################################
# Behavior server
###############################################################################
behavior_server:
  ros__parameters:
    use_sim_time: false
    global_frame: "map"
    robot_base_frame: "base_link"
    transform_tolerance: 0.2
    progress_check_timeout: 10.0
    cycle_frequency: 10.0
    enable_stamped_cmd_vel: false

###############################################################################
# Smoother server
###############################################################################
smoother_server:
  ros__parameters:
    use_sim_time: false
    smoother_plugins: ["simple_smoother"]

    simple_smoother:
      plugin: "nav2_smoother::SimpleSmoother"
      tolerance: 0.1
      max_its: 1000

###############################################################################
# Waypoint follower
###############################################################################
waypoint_follower:
  ros__parameters:
    use_sim_time: false
    loop_rate: 20
    stop_on_failure: true
    waypoint_task_executor_plugin: "wait_at_waypoint"
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: false
      waypoint_pause_duration: 0

###############################################################################
# Velocity smoother
###############################################################################
velocity_smoother:
  ros__parameters:
    use_sim_time: false
    smoothing_frequency: 20.0
    feedback: "OPEN_LOOP"
    scale_velocities: false
    max_velocity: [0.8, 0.0, 1.5]
    min_velocity: [0.0, 0.0, -1.5]

###############################################################################
# Global costmap
###############################################################################
global_costmap:
  ros__parameters:
    use_sim_time: false
    global_frame: "map"
    robot_base_frame: "base_link"
    update_frequency: 5.0
    publish_frequency: 2.0
    rolling_window: false
    track_unknown_space: true
    resolution: 0.05
    robot_radius: 0.20
    plugins: ["static_layer", "obstacle_layer", "inflation_layer"]

    static_layer:
      plugin: "nav2_costmap_2d::StaticLayer"
      map_subscribe_transient_local: true

    obstacle_layer:
      plugin: "nav2_costmap_2d::ObstacleLayer"
      observation_sources: "scan"
      scan:
        topic: "scan"
        max_obstacle_height: 2.0
        clearing: true
        marking: true
        data_type: "LaserScan"

    inflation_layer:
      plugin: "nav2_costmap_2d::InflationLayer"
      inflation_radius: 0.55
      cost_scaling_factor: 3.0

###############################################################################
# Local costmap
###############################################################################
local_costmap:
  ros__parameters:
    use_sim_time: false
    global_frame: "odom"
    robot_base_frame: "base_link"
    update_frequency: 10.0
    publish_frequency: 5.0
    rolling_window: true
    track_unknown_space: true
    width: 4.0
    height: 4.0
    resolution: 0.05
    robot_radius: 0.20
    plugins: ["static_layer", "obstacle_layer", "inflation_layer"]

    static_layer:
      plugin: "nav2_costmap_2d::StaticLayer"
      map_subscribe_transient_local: true

    obstacle_layer:
      plugin: "nav2_costmap_2d::ObstacleLayer"
      observation_sources: "scan"
      scan:
        topic: "scan"
        max_obstacle_height: 2.0
        clearing: true
        marking: true
        data_type: "LaserScan"

    inflation_layer:
      plugin: "nav2_costmap_2d::InflationLayer"
      inflation_radius: 0.55
      cost_scaling_factor: 3.0```

# `nav2_params.yaml.bak`
```
cd ~/Desktop/ros2_mapping_project
cp nav2_params.yaml nav2_params.yaml.bak   # backup your current file

cat > nav2_params.yaml << 'EOF'
amcl:
  ros__parameters:
    use_sim_time: false
    alpha1: 0.2
    alpha2: 0.2
    alpha3: 0.2
    alpha4: 0.2
    alpha5: 0.2
    base_frame_id: "base_link"
    beam_skip_distance: 0.5
    beam_skip_error_threshold: 0.9
    beam_skip_threshold: 0.3
    do_beamskip: false
    global_frame_id: "map"
    lambda_short: 0.1
    laser_likelihood_max_dist: 2.0
    laser_max_range: 10.0
    laser_min_range: 0.1
    laser_model_type: "likelihood_field"
    max_beams: 60
    max_particles: 2000
    min_particles: 500
    odom_frame_id: "odom"
    pf_err: 0.05
    pf_z: 0.99
    recovery_alpha_fast: 0.0
    recovery_alpha_slow: 0.0
    resample_interval: 1
    robot_model_type: "diff"
    scan_topic: "scan"
    tf_broadcast: true
    transform_tolerance: 1.0
    update_min_a: 0.1
    update_min_d: 0.1
    z_hit: 0.5
    z_max: 0.05
    z_rand: 0.5
    z_short: 0.05

map_server:
  ros__parameters:
    use_sim_time: false
    yaml_filename: ""
    frame_id: "map"
    topic_name: "map"
    use_pose: false

###############################################################################
# Planner server
###############################################################################
planner_server:
  ros__parameters:
    use_sim_time: false
    expected_planner_frequency: 20.0
    planner_plugins: ["GridBased"]

    GridBased:
      plugin: "nav2_smac_planner/SmacPlanner2D"
      tolerance: 0.12
      downsample_costmap: false
      allow_unknown: true
      max_iterations: 1000000
      max_on_approach_iterations: 1000
      motion_model_for_search: "Dubin"
      angle_quantization_bins: 72
      minimum_turning_radius: 0.25
      cost_travel_multiplier: 2.0
      debug_visualizations: false

###############################################################################
# Controller server
###############################################################################
controller_server:
  ros__parameters:
    use_sim_time: false
    controller_frequency: 10.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.001

    progress_checker_plugins: ["progress_checker"]
    goal_checker_plugins: ["goal_checker"]
    controller_plugins: ["FollowPath"]

    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.10
      movement_time_allowance: 10.0

    goal_checker:
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.08
      yaw_goal_tolerance: 0.15
      stateful: true

    FollowPath:
      plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"
      desired_linear_vel: 0.4
      min_linear_vel: 0.05
      max_angular_vel: 1.5
      min_angular_vel: 0.1
      lookahead_dist: 0.6
      min_lookahead_dist: 0.3
      max_lookahead_dist: 0.8
      lookahead_time: 1.5
      rotate_to_heading_angular_vel: 1.0
      transform_tolerance: 0.2
      use_velocity_scaled_lookahead_dist: true
      use_cost_regulated_linear_velocity_scaling: true
      regulated_linear_scaling_min_radius: 0.9
      regulated_linear_scaling_min_speed: 0.05
      use_collision_detection: true
      max_allowed_time_to_collision_up_to_carrot: 1.0
      use_rotate_to_heading: true
      rotate_to_heading_min_angle: 0.785

###############################################################################
# BT Navigator
###############################################################################
bt_navigator:
  ros__parameters:
    use_sim_time: false
    global_frame: "map"
    robot_base_frame: "base_link"
    odom_topic: "odom"
    transform_tolerance: 0.2
    default_server_timeout: 20.0
    wait_for_service_timeout: 5.0
    bt_loop_duration: 10
    goal_reached_tol: 0.05

    # Use your simple tree for both single-goal and multi-goal
    default_nav_to_pose_bt_xml: "/home/team4/Desktop/ros2_mapping_project/simple_nav.xml"
    default_nav_through_poses_bt_xml: "/home/team4/Desktop/ros2_mapping_project/simple_nav.xml"

    plugin_lib_names:
      - nav2_compute_path_to_pose_action_bt_node
      - nav2_compute_path_through_poses_action_bt_node
      - nav2_follow_path_action_bt_node
      - nav2_goal_reached_condition_bt_node
      - nav2_is_path_valid_condition_bt_node
      - nav2_clear_costmap_service_bt_node
      - nav2_distance_traveled_condition_bt_node
      - nav2_rate_controller_bt_node
      - nav2_speed_controller_bt_node
      - nav2_truncate_path_action_bt_node
      - nav2_reinitialize_global_localization_service_bt_node
      - nav2_remove_passed_goals_action_bt_node
      - nav2_back_up_action_bt_node
      - nav2_spin_action_bt_node
      - nav2_wait_action_bt_node

###############################################################################
# Behavior server
###############################################################################
behavior_server:
  ros__parameters:
    use_sim_time: false
    global_frame: "map"
    robot_base_frame: "base_link"
    transform_tolerance: 0.2
    progress_check_timeout: 10.0
    cycle_frequency: 10.0
    enable_stamped_cmd_vel: false

###############################################################################
# Smoother server
###############################################################################
smoother_server:
  ros__parameters:
    use_sim_time: false
    smoother_plugins: ["simple_smoother"]

    simple_smoother:
      plugin: "nav2_smoother::SimpleSmoother"
      tolerance: 0.1
      max_its: 1000

###############################################################################
# Waypoint follower
###############################################################################
waypoint_follower:
  ros__parameters:
    use_sim_time: false
    loop_rate: 20
    stop_on_failure: true
    waypoint_task_executor_plugin: "wait_at_waypoint"
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: false
      waypoint_pause_duration: 0.0

###############################################################################
# Velocity smoother
###############################################################################
velocity_smoother:
  ros__parameters:
    use_sim_time: false
    smoothing_frequency: 20.0
    feedback: "OPEN_LOOP"
    scale_velocities: false
    max_velocity: 0.8
    min_velocity: 0.0

###############################################################################
# Global costmap
###############################################################################
global_costmap:
  ros__parameters:
    use_sim_time: false
    global_frame: "map"
    robot_base_frame: "base_link"
    update_frequency: 5.0
    publish_frequency: 2.0
    rolling_window: false
    track_unknown_space: true
    resolution: 0.05
    robot_radius: 0.20
    plugins: ["static_layer", "obstacle_layer", "inflation_layer"]

    static_layer:
      plugin: "nav2_costmap_2d::StaticLayer"
      map_subscribe_transient_local: true

    obstacle_layer:
      plugin: "nav2_costmap_2d::ObstacleLayer"
      observation_sources: "scan"
      scan:
        topic: "scan"
        max_obstacle_height: 2.0
        clearing: true
        marking: true
        data_type: "LaserScan"

    inflation_layer:
      plugin: "nav2_costmap_2d::InflationLayer"
      inflation_radius: 0.55
      cost_scaling_factor: 3.0

###############################################################################
# Local costmap
###############################################################################
local_costmap:
  ros__parameters:
    use_sim_time: false
    global_frame: "odom"
    robot_base_frame: "base_link"
    update_frequency: 10.0
    publish_frequency: 5.0
    rolling_window: true
    track_unknown_space: true
    width: 4.0
    height: 4.0
    resolution: 0.05
    robot_radius: 0.20
    plugins: ["static_layer", "obstacle_layer", "inflation_layer"]

    static_layer:
      plugin: "nav2_costmap_2d::StaticLayer"
      map_subscribe_transient_local: true

    obstacle_layer:
      plugin: "nav2_costmap_2d::ObstacleLayer"
      observation_sources: "scan"
      scan:
        topic: "scan"
        max_obstacle_height: 2.0
        clearing: true
        marking: true
        data_type: "LaserScan"

    inflation_layer:
      plugin: "nav2_costmap_2d::InflationLayer"
      inflation_radius: 0.55
      cost_scaling_factor: 3.0
EOF
```

# `odom_params.yaml`
```
ekf_filter_node:
  ros__parameters:
    frequency: 50.0
    sensor_timeout: 0.2
    two_d_mode: true
    publish_tf: true

    map_frame: map
    odom_frame: odom
    base_link_frame: base_link
    world_frame: odom

    # -------------- wheel odom: x, y, vx only --------------
    odom0: wheel_odom
    #        x     y     z    roll pitch yaw   vx    vy    vz   vroll vpitch vyaw  ax   ay   az
    odom0_config: [true, true, false,
                   false, false, false,
                   true, false, false,
                   false, false, false,
                   false, false, false]
    odom0_queue_size: 10
    odom0_differential: false
    odom0_relative: false

    # -------------- IMU (from imu_filter_madgwick) : yaw + yaw rate only --------------
    imu0: imu/data
    #        x     y     z    roll pitch yaw   vx    vy    vz   vroll vpitch vyaw  ax   ay   az
    imu0_config: [false, false, false,
                  false, false, true,
                  false, false, false,
                  false, false, true,
                  false, false, false]
    imu0_queue_size: 10
    imu0_differential: false
    imu0_relative: false
    imu0_remove_gravitational_acceleration: true
```

# `package.xml`
```
<?xml version="1.0"?>
<package format="3">
  <name>ros2_mapping_project</name>
  <version>0.0.1</version>
  <description>Custom RPLIDAR + IMU mapping with SLAM and Nav2</description>
  <maintainer email="team4@example.com">team4</maintainer>
  <license>BSD-3-Clause</license>
  <buildtool_depend>ament_python</buildtool_depend>
  <exec_depend>rclpy</exec_depend>
  <exec_depend>sensor_msgs</exec_depend>
  <exec_depend>nav_msgs</exec_depend>
  <exec_depend>geometry_msgs</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>tf2_ros</exec_depend>
  <exec_depend>slam_toolbox</exec_depend>
  <exec_depend>robot_localization</exec_depend>
  <exec_depend>imu_filter_madgwick</exec_depend>
  <exec_depend>twist_mux</exec_depend>
  <exec_depend>nav2_velocity_smoother</exec_depend>
  <exec_depend>nav2_bringup</exec_depend>
  <exec_depend>rviz2</exec_depend>
  <exec_depend>sllidar_ros2</exec_depend>
  <exec_depend>teleop_twist_keyboard</exec_depend> <!-- for manual testing -->
  <export><build_type>ament_python</build_type></export>
</package>
```

# `pca_dual_manual_test.py`
```
#!/usr/bin/env python3
import sys, termios, tty, time
import smbus

# ==== USER SETTINGS (edit if needed) ====
BUS_NUM      = 1          # i2c-1
ADDR_ENA     = 0x41       # PCA driving EnA, In1, In2  (RIGHT side by default)
ADDR_ENB     = 0x60       # PCA driving EnB, In3, In4  (LEFT side by default)
ENA_CH       = 0          # EnA PWM channel on ADDR_ENA
IN1_CH       = 1          # In1 digital channel on ADDR_ENA
IN2_CH       = 2          # In2 digital channel on ADDR_ENA
ENB_CH       = 0          # EnB PWM channel on ADDR_ENB
IN3_CH       = 1          # In3 digital channel on ADDR_ENB
IN4_CH       = 2          # In4 digital channel on ADDR_ENB

PWM_FREQ_HZ  = 300.0      # PCA9685 PWM frequency
START_DUTY   = 0.90       # 30% starting duty
STEP_DUTY    = 0.05       # +/-5% per tap
MIN_DUTY     = 0.10       # don't go below 10% (helps overcome stiction)
MAX_DUTY     = 1.00

# If your wheels spin the wrong way, toggle these at runtime with 'R'/'L'
INVERT_RIGHT = True
INVERT_LEFT  = False
# ========================================

# PCA9685 registers
_MODE1      = 0x00
_MODE2      = 0x01
_LED0_ON_L  = 0x06
_PRESCALE   = 0xFE

_RESTART = 1 << 7
_SLEEP   = 1 << 4
_AI      = 1 << 5
_OUTDRV  = 1 << 2  # totem-pole output stage

def _clip(v, lo, hi): return hi if v > hi else lo if v < lo else v

class PCA9685:
    def __init__(self, bus, addr, freq_hz=300.0):
        self.bus = bus
        self.addr = addr
        # sleep + auto-increment to set prescale
        self._w8(_MODE1, _SLEEP | _AI)
        self._w8(_MODE2, _OUTDRV)
        time.sleep(0.005)
        self.set_pwm_freq(freq_hz)
        # wake + restart
        old = self._r8(_MODE1)
        self._w8(_MODE1, (old & ~_SLEEP) | _RESTART | _AI)
        time.sleep(0.005)

    def set_pwm_freq(self, f_hz: float):
        f_hz = float(f_hz)
        prescale = int(round(25_000_000.0 / (4096.0 * f_hz) - 1.0))
        prescale = _clip(prescale, 3, 255)
        old = self._r8(_MODE1)
        self._w8(_MODE1, (old | _SLEEP) & 0x7F)
        self._w8(_PRESCALE, prescale)
        self._w8(_MODE1, old | _AI)
        time.sleep(0.005)
        self._w8(_MODE1, old | _AI | _RESTART)

    def set_off(self, ch: int):
        base = _LED0_ON_L + 4*ch
        # full OFF (OFF_H bit4 = 1)
        self.bus.write_i2c_block_data(self.addr, base, [0x00,0x00,0x00,0x10])

    def set_on(self, ch: int):
        base = _LED0_ON_L + 4*ch
        # full ON (ON_H bit4 = 1)
        self.bus.write_i2c_block_data(self.addr, base, [0x00,0x10,0x00,0x00])

    def set_pwm(self, ch: int, duty01: float):
        duty01 = _clip(duty01, 0.0, 1.0)
        if duty01 <= 0.0: self.set_off(ch); return
        if duty01 >= 1.0: self.set_on(ch);  return
        off = int(round(duty01 * 4095.0))
        base = _LED0_ON_L + 4*ch
        self.bus.write_i2c_block_data(self.addr, base, [0x00,0x00, off & 0xFF, (off>>8) & 0x0F])

    def _w8(self, reg, val): self.bus.write_byte_data(self.addr, reg, val & 0xFF)
    def _r8(self, reg):       return self.bus.read_byte_data(self.addr, reg) & 0xFF


def getch():
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return ch

def print_help(duty, invR, invL):
    print(
f"""
W/A/S/D to move | Space=Coast | B=Brake | +/- duty | R/L invert side | Q quit
Duty: {int(duty*100)}%   Invert Right: {invR}   Invert Left: {invL}
Right = EnA @ 0x{ADDR_ENA:02X} (ENA={ENA_CH}, IN1={IN1_CH}, IN2={IN2_CH})
Left  = EnB @ 0x{ADDR_ENB:02X} (ENB={ENB_CH}, IN3={IN3_CH}, IN4={IN4_CH})
"""
    )

def main():
    bus = smbus.SMBus(BUS_NUM)
    pcaA = PCA9685(bus, ADDR_ENA, PWM_FREQ_HZ)  # EnA, In1, In2 (RIGHT)
    pcaB = PCA9685(bus, ADDR_ENB, PWM_FREQ_HZ)  # EnB, In3, In4 (LEFT)

    # Start safe: everything OFF
    for ch in (ENA_CH, IN1_CH, IN2_CH): pcaA.set_off(ch)
    for ch in (ENB_CH, IN3_CH, IN4_CH): pcaB.set_off(ch)

    duty = START_DUTY
    invR = INVERT_RIGHT
    invL = INVERT_LEFT

    def right_forward():
        fwd = not invR
        if fwd:
            pcaA.set_on(IN1_CH); pcaA.set_off(IN2_CH)
        else:
            pcaA.set_off(IN1_CH); pcaA.set_on(IN2_CH)

    def right_reverse():
        fwd = not invR
        if fwd:
            pcaA.set_off(IN1_CH); pcaA.set_on(IN2_CH)
        else:
            pcaA.set_on(IN1_CH);  pcaA.set_off(IN2_CH)

    def right_coast():
        pcaA.set_off(IN1_CH); pcaA.set_off(IN2_CH)

    def right_brake():
        pcaA.set_on(IN1_CH);  pcaA.set_on(IN2_CH)

    def left_forward():
        fwd = not invL
        if fwd:
            pcaB.set_on(IN3_CH); pcaB.set_off(IN4_CH)
        else:
            pcaB.set_off(IN3_CH); pcaB.set_on(IN4_CH)

    def left_reverse():
        fwd = not invL
        if fwd:
            pcaB.set_off(IN3_CH); pcaB.set_on(IN4_CH)
        else:
            pcaB.set_on(IN3_CH);  pcaB.set_off(IN4_CH)

    def left_coast():
        pcaB.set_off(IN3_CH); pcaB.set_off(IN4_CH)

    def left_brake():
        pcaB.set_on(IN3_CH);  pcaB.set_on(IN4_CH)

    def enable_both(d):
        if d <= 0.0:
            pcaA.set_off(ENA_CH); pcaB.set_off(ENB_CH)
        else:
            pcaA.set_pwm(ENA_CH, d)
            pcaB.set_pwm(ENB_CH, d)

    print_help(duty, invR, invL)

    try:
        while True:
            c = getch()
            if c in ('q', 'Q'):
                break
            elif c in ('+', '='):
                duty = _clip(duty + STEP_DUTY, MIN_DUTY, MAX_DUTY)
                print_help(duty, invR, invL)
            elif c in ('-', '_'):
                duty = _clip(duty - STEP_DUTY, MIN_DUTY, MAX_DUTY)
                print_help(duty, invR, invL)
            elif c in ('r', 'R'):
                invR = not invR
                print_help(duty, invR, invL)
            elif c in ('l', 'L'):
                invL = not invL
                print_help(duty, invR, invL)

            elif c in ('w', 'W'):
                # forward both
                right_forward(); left_forward(); enable_both(duty)
            elif c in ('s', 'S'):
                # reverse both
                right_reverse(); left_reverse(); enable_both(duty)
            elif c in ('a', 'A'):
                # spin left: right fwd, left rev
                right_forward(); left_reverse(); enable_both(duty)
            elif c in ('d', 'D'):
                # spin right: right rev, left fwd
                right_reverse(); left_forward(); enable_both(duty)
            elif c == ' ':
                # coast stop (all IN low, EN off)
                enable_both(0.0); right_coast(); left_coast()
            elif c in ('b', 'B'):
                # brake stop (both IN high, EN off)
                enable_both(0.0); right_brake(); left_brake()
            else:
                # ignore other keys
                pass
    finally:
        # Safe shutdown
        try:
            enable_both(0.0)
            right_coast(); left_coast()
            bus.close()
        except Exception:
            pass
        print("\nExited. Motors OFF.")

if __name__ == "__main__":
    main()
```

# `pseudo_odom_node.py`
```
#!/usr/bin/env python3
import math
import time

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy

from sensor_msgs.msg import Imu, LaserScan
from nav_msgs.msg import Odometry
from geometry_msgs.msg import TransformStamped
import tf2_ros


# ---------- small helpers (no external deps) ----------
def quaternion_from_yaw(yaw: float):
    """Return (x,y,z,w) for Z-rotation only."""
    cy = math.cos(0.5 * yaw)
    sy = math.sin(0.5 * yaw)
    return (0.0, 0.0, sy, cy)

def yaw_from_quat(x: float, y: float, z: float, w: float):
    """Extract Z yaw from quaternion (XYZ order, ZYX yaw)."""
    siny_cosp = 2.0 * (w * z + x * y)
    cosy_cosp = 1.0 - 2.0 * (y * y + z * z)
    return math.atan2(siny_cosp, cosy_cosp)


class PseudoOdom(Node):
    """
    Minimal odom estimator:
      - Yaw from /imu/raw orientation.
      - Forward speed from LiDAR by tracking the range straight ahead.
      - Integrates x,y over time: x += v*dt*cos(yaw), y += v*dt*sin(yaw).
    This is a crude stand-in for encoders, just to keep SLAM updating.
    """

    def __init__(self):
        super().__init__('pseudo_odom_node')

        # Params
        self.declare_parameter('scan_topic', '/scan')
        self.declare_parameter('imu_topic', '/imu/raw')
        self.declare_parameter('base_frame', 'base_link')
        self.declare_parameter('odom_frame', 'odom')
        self.declare_parameter('publish_tf', True)
        self.declare_parameter('speed_alpha', 0.6)      # low-pass on v
        self.declare_parameter('max_abs_speed', 1.5)    # m/s clamp
        self.declare_parameter('center_avg_beams', 5)   # odd number preferred

        self.scan_topic = self.get_parameter('scan_topic').get_parameter_value().string_value
        self.imu_topic = self.get_parameter('imu_topic').get_parameter_value().string_value
        self.base_frame = self.get_parameter('base_frame').get_parameter_value().string_value
        self.odom_frame = self.get_parameter('odom_frame').get_parameter_value().string_value
        self.publish_tf = self.get_parameter('publish_tf').get_parameter_value().bool_value
        self.speed_alpha = float(self.get_parameter('speed_alpha').value)
        self.max_abs_speed = float(self.get_parameter('max_abs_speed').value)
        self.center_avg_beams = int(self.get_parameter('center_avg_beams').value)

        # State
        self.x = 0.0
        self.y = 0.0
        self.yaw = 0.0
        self.vx = 0.0
        self.last_r_center = None
        self.last_scan_time = None
        self.have_imu = False

        # QoS
        sensor_qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=10,
            durability=DurabilityPolicy.VOLATILE,
        )

        # IO
        self.sub_imu = self.create_subscription(Imu, self.imu_topic, self.on_imu, sensor_qos)
        self.sub_scan = self.create_subscription(LaserScan, self.scan_topic, self.on_scan, sensor_qos)
        self.pub_odom = self.create_publisher(Odometry, '/odom', 10)

        self.br = tf2_ros.TransformBroadcaster(self) if self.publish_tf else None

        # Publish at fixed rate to keep consumers alive even if scans slow down
        self.timer = self.create_timer(0.02, self.on_tick)  # 50 Hz tick

        self.get_logger().info(
            f'Listening: scan={self.scan_topic}, imu={self.imu_topic}; frames: {self.odom_frame}->{self.base_frame}'
        )

    # ----- callbacks -----
    def on_imu(self, msg: Imu):
        # Use IMU orientation for yaw
        qx, qy, qz, qw = msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w
        self.yaw = yaw_from_quat(qx, qy, qz, qw)
        self.have_imu = True

    def on_scan(self, msg: LaserScan):
        now = self.get_clock().now()
        t = now.nanoseconds * 1e-9
        dt = None if self.last_scan_time is None else (t - self.last_scan_time)
        self.last_scan_time = t

        # pick a small window of beams around "straight ahead"
        # Assume laser frame X-forward at angle 0; if your driver uses different zero, adjust here.
        n = len(msg.ranges)
        if n == 0:
            return

        # beam index at angle closest to 0
        zero_idx = int(round((0.0 - msg.angle_min) / msg.angle_increment))
        half = max(0, (self.center_avg_beams - 1) // 2)
        i0 = max(0, zero_idx - half)
        i1 = min(n - 1, zero_idx + half)
        window = [r for r in msg.ranges[i0:i1 + 1] if math.isfinite(r) and msg.range_min < r < msg.range_max]

        if not window:
            return

        r_center = sum(window) / float(len(window))

        # Estimate forward speed from change in distance to the target straight ahead
        # v ≈ -(r_now - r_prev)/dt. Negative sign: if distance to wall decreases, we move forward.
        if self.last_r_center is not None and dt and dt > 1e-3:
            raw_v = -(r_center - self.last_r_center) / dt
            # Low-pass filter and clamp
            v = self.speed_alpha * raw_v + (1.0 - self.speed_alpha) * self.vx
            v = max(-self.max_abs_speed, min(self.max_abs_speed, v))
            self.vx = v

        self.last_r_center = r_center

    def on_tick(self):
        # integrate pose with the latest v and yaw; if no IMU yet, keep yaw=0
        now = self.get_clock().now().nanoseconds * 1e-9
        if not hasattr(self, '_last_tick'):
            self._last_tick = now
            return
        dt = now - self._last_tick
        self._last_tick = now
        if dt <= 0.0 or dt > 1.0:
            return  # skip unreasonable dt

        # dead-reckon
        self.x += self.vx * dt * math.cos(self.yaw)
        self.y += self.vx * dt * math.sin(self.yaw)

        # publish Odometry
        odom = Odometry()
        odom.header.stamp = self.get_clock().now().to_msg()
        odom.header.frame_id = self.odom_frame
        odom.child_frame_id = self.base_frame

        odom.pose.pose.position.x = float(self.x)
        odom.pose.pose.position.y = float(self.y)
        odom.pose.pose.position.z = 0.0
        qx, qy, qz, qw = quaternion_from_yaw(self.yaw)
        odom.pose.pose.orientation.x = qx
        odom.pose.pose.orientation.y = qy
        odom.pose.pose.orientation.z = qz
        odom.pose.pose.orientation.w = qw

        # simple covariances
        odom.pose.covariance = [
            0.05, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.05, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 9999.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 9999.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 9999.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.10
        ]
        odom.twist.twist.linear.x = float(self.vx)
        odom.twist.twist.linear.y = 0.0
        odom.twist.twist.angular.z = 0.0

        self.pub_odom.publish(odom)

        # publish TF odom->base_link
        if self.br:
            tf = TransformStamped()
            tf.header.stamp = odom.header.stamp
            tf.header.frame_id = self.odom_frame
            tf.child_frame_id = self.base_frame
            tf.transform.translation.x = odom.pose.pose.position.x
            tf.transform.translation.y = odom.pose.pose.position.y
            tf.transform.translation.z = 0.0
            tf.transform.rotation.x = qx
            tf.transform.rotation.y = qy
            tf.transform.rotation.z = qz
            tf.transform.rotation.w = qw
            self.br.sendTransform(tf)


def main():
    rclpy.init()
    node = PseudoOdom()
    try:
        rclpy.spin(node)
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

# `setup.py`
```
from setuptools import setup
from glob import glob
import os

package_name = 'ros2_mapping_project'

setup(
    name=package_name,
    version='0.0.1',

    # Define a proper Python package so ament_python creates lib/ros2_mapping_project
    packages=[package_name],
    # Install your top-level node scripts as modules so console_scripts can import them
    py_modules=[
        'lidar_node',
        'imu_node',
        'encoders_node',
        'motor_driver_pca_reg_dual',
        'mapping_launch',
        'wasd_teleop',
        'keyboard_gpio_drive',
    ],

    data_files=[
        ('share/ament_index/resource_index/packages',
         ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
        (os.path.join('share', package_name, 'description'), glob('description/*.urdf')),
        (os.path.join('share', package_name), glob('*.yaml')),
        (os.path.join('share', package_name), glob('*.rviz')),
    ],

    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='team4',
    maintainer_email='team4@example.com',
    description='Custom mapping',
    license='BSD-3-Clause',

    entry_points={
        'console_scripts': [
            # These names are what you use as executable= in launch files
            'lidar_node = lidar_node:main',
            'imu_node = imu_node:main',
            'encoders_node = encoders_node:main',
            'motor_driver_node = motor_driver_pca_reg_dual:main',
            # optional convenience:
            # 'wasd_teleop = wasd_teleop:main',
        ],
    },
)
```

# `setup.py.save`
```
from setuptools import setup
from glob import glob
import os

package_name = 'ros2_mapping_project'

setup(
    name=package_name,
    version='0.0.1',
    # No Python package directory, we use top-level .py modules
    packages=[],
    py_modules=[
        'lidar_node',
        'imu_node',
        'encoders_node',
        'motor_driver_pca_reg_dual',
        'mapping_launch',
        'wasd_teleop',
        'keyboard_gpio_drive',
    ],
    data_files=[
        ('share/ament_index/resource_index/packages',
         ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
        (os.path.join('share', package_name, 'description'), glob('description/*.urdf')),
        (os.path.join('share', package_name), glob('*.yaml')),
        (os.path.join('share', package_name), glob('*.rviz')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='team4',
    maintainer_email='team4@example.com',
    description='Custom mapping',
    license='BSD-3-Clause',
    entry_points={
        'console_scripts': [
            'lidar_node = lidar_node:main',
            'imu_node = imu_node:main',
            'encoders_node = encoders_node:main',
            'motor_driver_node = motor_driver_pca_reg_dual:main',
            # optional:
            # 'wasd_teleop = wasd_teleop:main',
        ],
    },
)
```

# `simple_nav.xml`
```
<?xml version="1.0"?>
<root main_tree_to_execute="MainTree">
  <BehaviorTree ID="MainTree">
    <!-- Single-goal navigation: compute a path and follow it -->
    <Sequence name="NavigateToPoseSimple">
      <ComputePathToPose goal="{goal}" path="{path}"/>
      <FollowPath       path="{path}"/>
    </Sequence>
  </BehaviorTree>
</root>
```

# `slam.rviz`
```
Panels:
- Class: rviz_common/Displays
  Name: Displays
- Class: rviz_common/Selection
  Name: Selection
Visualization Manager:
  Class: ""
  Displays:
  - Class: rviz_default_plugins/TF
    Name: TF
  - Class: rviz_default_plugins/Map
    Name: Map
    Topic: /map
  - Class: rviz_default_plugins/LaserScan
    Name: Scan
    Topic: /scan
  - Class: rviz_default_plugins/Odometry
    Name: Odom
    Topic: /odometry/filtered
  Global Options:
    Fixed Frame: map
```

# `slam_params.yaml`
```
slam_toolbox:
  ros__parameters:
    mode: mapping
    scan_topic: /scan
    map_frame: map
    base_frame: base_link
    odom_frame: odom

    # Extra scan-matcher / search tuning
    ceres_solver_iteration_limit: 20
    correlation_search_space_dimension: 1.0
    correlation_search_space_resolution: 0.01
    loop_search_space_dimension: 8.0
    loop_search_space_resolution: 0.05
    loop_search_minimum_distance: 2.0
    sigma: 0.05

    provide_odom_frame: false    # EKF publishes odom->base_link
    publish_tf: true             # SLAM publishes map->odom

    # Set to false to use the TF from odom->base_link as an initial guess for scan matching.
    # This is the recommended setting when using an external odometry source like the EKF.
    # Set to true if you want to subscribe to an odometry topic directly.
    use_odometry: false
    use_scan_matching: true

    # Laser range is critical. Set to match your sensor's capabilities.
    # RPLidar A1/A2 is ~0.2m to ~12.0m.
    laser_min_range: 0.2
    laser_max_range: 12.0

    minimum_travel_distance: 0.03
    minimum_travel_rotation: 0.04
    minimum_time_interval: 0.05
    resolution: 0.05
    map_publish_period: 0.2
    transform_publish_period: 0.05
    queue_size: 500```

# `slam_params_no_ekf.yaml`
```
slam_toolbox:
  ros__parameters:
    mode: mapping
    scan_topic: /scan
    map_frame: map
    base_frame: base_link
    odom_frame: odom

    provide_odom_frame: true     # SLAM publishes odom->base_link
    publish_tf: true             # SLAM publishes map->odom
    use_odometry: false          # rely on scan matching only

    minimum_travel_distance: 0.03
    minimum_travel_rotation: 0.04
    minimum_time_interval: 0.05
    resolution: 0.05
    map_publish_period: 0.2
    transform_publish_period: 0.05
    queue_size: 500```

# `slam_reset_key.py`
```
#!/usr/bin/env python3
import sys
import time
import termios
import tty

import rclpy
from rclpy.node import Node
from std_srvs.srv import Empty


class SlamResetNode(Node):
    def __init__(self):
        super().__init__('slam_reset_node')
        self.cli = self.create_client(Empty, '/slam_toolbox/clear')
        self.get_logger().info("Waiting for /slam_toolbox/clear service...")
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().warn('/slam_toolbox/clear not available yet...')
        self.get_logger().info("Connected to /slam_toolbox/clear.")

    def reset_map(self):
        req = Empty.Request()
        future = self.cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)
        if future.result() is not None:
            self.get_logger().info("SLAM map cleared.")
        else:
            self.get_logger().error(f"Service call failed: {future.exception()}")


def main():
    rclpy.init()
    node = SlamResetNode()

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)

    cooldown = 1.0   # seconds
    last_reset = 0.0

    print("")
    print("=== SLAM reset keyboard helper ===")
    print("Press 'r' to clear the slam_toolbox map.")
    print(f"Resets allowed at most once every {cooldown:.0f} seconds.")
    print("Press 'q' or Ctrl+C to quit.")
    print("===================================")

    try:
        tty.setcbreak(fd)  # raw-ish keyboard
        while rclpy.ok():
            ch = sys.stdin.read(1)
            now = time.time()

            if ch == 'r':
                dt = now - last_reset
                if dt < cooldown:
                    remaining = cooldown - dt
                    print(f"[cooldown] Wait {remaining:.1f} s before next reset.")
                    continue

                print("[key] 'r' pressed -> clearing SLAM map...")
                node.reset_map()
                last_reset = time.time()
                print(f"[info] You can reset again in {cooldown:.0f} s.")

            elif ch in ('q', '\x03'):  # 'q' or Ctrl+C
                print("[exit] Quitting slam_reset_key.")
                break

    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

# `tasks.json`
```
{
  "version": "2.0.0",
  "tasks": [
    { "label": "Build Project", "type": "shell", "command": "colcon build --symlink-install", "group": "build" },
    { "label": "Source Setup", "type": "shell", "command": "source install/setup.bash" },
    { "label": "Launch with IMU", "type": "shell", "command": "killall -9 ros2; ros2 launch ros2_mapping_project mapping_launch.py" },
    { "label": "Launch no IMU", "type": "shell", "command": "killall -9 ros2; ros2 launch ros2_mapping_project mapping_launch_no_imu.py" }
  ]
}
```

# `test.py`
```
# save as bno055_imu_node.py, then: python3 bno055_imu_node.py
import time
from smbus2 import SMBus
import board, busio
import adafruit_bno055
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu
from geometry_msgs.msg import Quaternion
import math

def quat_from_euler(roll, pitch, yaw):
    cr, sr = math.cos(roll/2), math.sin(roll/2)
    cp, sp = math.cos(pitch/2), math.sin(pitch/2)
    cy, sy = math.cos(yaw/2), math.sin(yaw/2)
    return Quaternion(
        x=sr*cp*cy - cr*sp*cy,
        y=cr*sp*sy + sr*cp*sy,
        z=cr*cp*sy - sr*sp*cy,
        w=cr*cp*cy + sr*sp*sy
    )

class BNO055Node(Node):
    def __init__(self):
        super().__init__('bno055_imu')
        # Try common I²C bus; adjust if needed
        i2c = busio.I2C(board.SCL, board.SDA)
        self.bno = adafruit_bno055.BNO055_I2C(i2c)  # uses 0x28 by default
        self.pub = self.create_publisher(Imu, 'imu/data', 10)
        self.timer = self.create_timer(0.02, self.tick)  # 50 Hz

    def tick(self):
        euler = self.bno.euler  # degrees (heading, roll, pitch)
        gyro = self.bno.gyro    # rad/s
        accel = self.bno.linear_acceleration  # m/s^2
        if not euler or not gyro or not accel:
            return
        yaw, roll, pitch = [math.radians(x) for x in euler]  # note ordering
        msg = Imu()
        msg.orientation = quat_from_euler(roll, pitch, yaw)
        msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z = gyro
        msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z = accel
        self.pub.publish(msg)

def main():
    rclpy.init()
    n = BNO055Node()
    rclpy.spin(n)
    n.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

# `testen.py`
```
# /tmp/pinpeek.py
import Jetson.GPIO as GPIO, time
GPIO.setmode(GPIO.BOARD); GPIO.setwarnings(False)
for p in (12,16,7,11): GPIO.setup(p, GPIO.IN)   # 12/16 = left, 7/11 = right
print("Press Ctrl+C to stop")
try:
    while True:
        la, lb = GPIO.input(12), GPIO.input(16)
        ra, rb = GPIO.input(7),  GPIO.input(11)
        print(f"L(A,B)=({la},{lb})   R(A,B)=({ra},{rb})")
        time.sleep(0.05)
finally:
    GPIO.cleanup()
```

# `tst.py`
```
#tewst```

# `wasd_motor_test.py`
```
#!/usr/bin/env python3
import sys, termios, tty, time
try:
    import Jetson.GPIO as GPIO
    HAS_GPIO = True
except Exception:
    HAS_GPIO = False

# ---- Pin map (BOARD numbers) ----
ENA = 15   # side A enable (PWM)
ENB = 32   # side B enable (PWM)
IN1 = 23   # A dir1
IN2 = 19   # A dir2
IN3 = 21   # B dir1
IN4 = 18   # B dir2

PWM_HZ = 1000
MIN_DUTY = 20.0  # dead-zone lift
duty = 40.0      # start duty

def kbhit():
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return ch

def set_side(speed, inA, inB, pwm):  # speed in [-1..1]
    if not HAS_GPIO:
        return
    if abs(speed) < 1e-3:
        # coast (both low)
        GPIO.output(inA, GPIO.LOW); GPIO.output(inB, GPIO.LOW)
        pwm.ChangeDutyCycle(0.0)
        return
    if speed > 0:
        # forward
        GPIO.output(inA, GPIO.HIGH); GPIO.output(inB, GPIO.LOW)
    else:
        # reverse
        GPIO.output(inA, GPIO.LOW);  GPIO.output(inB, GPIO.HIGH)
    pwm.ChangeDutyCycle(max(MIN_DUTY, min(100.0, abs(speed) * 100.0)))

def brake():
    if not HAS_GPIO: return
    for p in (IN1, IN2, IN3, IN4):
        GPIO.output(p, GPIO.LOW)

def stop_all(pwmA, pwmB):
    if not HAS_GPIO: return
    pwmA.ChangeDutyCycle(0.0)
    pwmB.ChangeDutyCycle(0.0)
    # coast
    GPIO.output(IN1, GPIO.LOW); GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.LOW); GPIO.output(IN4, GPIO.LOW)

def main():
    global duty
    if not HAS_GPIO:
        print("Jetson.GPIO not available; dry-run mode.")
    else:
        GPIO.setmode(GPIO.BOARD)
        GPIO.setwarnings(False)

        # Direction pins first
        for p in (IN1, IN2, IN3, IN4):
            GPIO.setup(p, GPIO.OUT, initial=GPIO.LOW)

        # ---- NVIDIA workaround: setup each PWM pin individually BEFORE creating PWM ----
        GPIO.setup(ENA, GPIO.OUT, initial=GPIO.LOW)
        pwmA = GPIO.PWM(ENA, PWM_HZ)
        pwmA.start(0.0)

        GPIO.setup(ENB, GPIO.OUT, initial=GPIO.LOW)
        pwmB = GPIO.PWM(ENB, PWM_HZ)
        pwmB.start(0.0)
        # ------------------------------------------------------------------------------

    print("""
W/S = forward/back
A/D = in-place turn left/right
Q/E = duty -5% / +5%   (current duty affects speed step)
Space = stop (coast)
X = brake (all low)
Esc or Ctrl-C = quit
""")

    # current command (left/right in [-1..1])
    left = 0.0
    right = 0.0

    try:
        while True:
            ch = kbhit()
            if ch in ('\x1b', '\x03'):  # Esc or Ctrl-C
                break
            elif ch in ('w','W'):
                left  = min(1.0, left  + duty/100.0)
                right = min(1.0, right + duty/100.0)
            elif ch in ('s','S'):
                left  = max(-1.0, left  - duty/100.0)
                right = max(-1.0, right - duty/100.0)
            elif ch in ('a','A'):
                # turn left in place: left backward, right forward
                left  = max(-1.0, left  - duty/100.0)
                right = min( 1.0, right + duty/100.0)
            elif ch in ('d','D'):
                # turn right in place: left forward, right backward
                left  = min( 1.0, left  + duty/100.0)
                right = max(-1.0, right - duty/100.0)
            elif ch in ('q','Q'):
                duty = max(5.0, duty - 5.0)
                print(f"duty={duty:.0f}%")
                # don’t change left/right immediately; next key will apply
            elif ch in ('e','E'):
                duty = min(100.0, duty + 5.0)
                print(f"duty={duty:.0f}%")
            elif ch == ' ':
                left = 0.0; right = 0.0
                if HAS_GPIO: stop_all(pwmA, pwmB)
                print("STOP (coast)")
            elif ch in ('x','X'):
                left = 0.0; right = 0.0
                if HAS_GPIO: brake()
                if HAS_GPIO:
                    pwmA.ChangeDutyCycle(0.0); pwmB.ChangeDutyCycle(0.0)
                print("BRAKE (both low)")
            else:
                # ignore unknown keys
                continue

            # apply outputs
            if HAS_GPIO:
                set_side(left,  IN1, IN2, pwmA)
                set_side(right, IN3, IN4, pwmB)

            print(f"L={left:+.2f} R={right:+.2f}  duty={duty:.0f}%")

    except KeyboardInterrupt:
        pass
    finally:
        if HAS_GPIO:
            try:
                stop_all(pwmA, pwmB)
                pwmA.stop(); pwmB.stop()
                for p in (IN1, IN2, IN3, IN4, ENA, ENB):
                    GPIO.output(p, GPIO.LOW)
            finally:
                GPIO.cleanup()

if __name__ == "__main__":
    main()
```

# `wasd_teleop.py`
```
#!/usr/bin/env python3
import sys, termios, tty, time
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_srvs.srv import Empty

HELP = """
WASD teleop  (/cmd_vel)
-----------------------
  W : forward      S : backward
  A : turn left    D : turn right
  Space : stop     Q : quit

  1/2 : linear speed -/+ (default 0.30 m/s)
  9/0 : angular speed -/+ (default 1.20 rad/s)

  R : reset SLAM map (/slam_toolbox/clear), 10s cooldown
"""

def getch():
    fd = sys.stdin.fileno()
    if not sys.stdin.isatty():
        return ''  # ignore if not a TTY
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return ch

class WasdTeleop(Node):
    def __init__(self):
        super().__init__('wasd_teleop')
        self.pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.lin = 0.30
        self.ang = 1.20

        # SLAM reset client
        self.slam_client = self.create_client(Empty, '/slam_toolbox/clear')
        self.reset_cooldown = 10.0  # seconds
        self.last_reset_time = 0.0

        if not self.slam_client.wait_for_service(timeout_sec=2.0):
            self.get_logger().warn(
                "/slam_toolbox/clear service not available yet. "
                "R will do nothing until slam_toolbox is running."
            )
        else:
            self.get_logger().info("Connected to /slam_toolbox/clear.")

        self.get_logger().info(HELP)

    def _publish(self, vx, wz, note=''):
        msg = Twist()
        msg.linear.x = float(vx)
        msg.angular.z = float(wz)
        self.pub.publish(msg)
        if note:
            self.get_logger().info(note)

    def _reset_slam(self):
        now = time.time()
        dt = now - self.last_reset_time

        if not self.slam_client.service_is_ready():
            self.get_logger().warn("SLAM reset requested but /slam_toolbox/clear is not available.")
            return

        if dt < self.reset_cooldown:
            remaining = self.reset_cooldown - dt
            self.get_logger().info(
                f"SLAM reset on cooldown. Wait {remaining:.1f} s before next reset."
            )
            return

        self.get_logger().info("Resetting SLAM map via /slam_toolbox/clear...")
        req = Empty.Request()
        future = self.slam_client.call_async(req)
        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)

        if future.result() is not None:
            self.last_reset_time = time.time()
            self.get_logger().info(
                "SLAM map cleared. Drive the robot to build a new map."
            )
        else:
            self.get_logger().error(
                f"SLAM reset failed: {future.exception()}"
            )

    def spin_keys(self):
        self._publish(0.0, 0.0, "ready: WASD, space=stop, r=reset SLAM, q=quit")
        while rclpy.ok():
            c = getch().lower()
            if not c:
                continue

            if   c == 'w':
                self._publish(self.lin, 0.0, f"cmd: forward  v={self.lin:.2f}")
            elif c == 's':
                self._publish(-self.lin, 0.0, f"cmd: back     v={-self.lin:.2f}")
            elif c == 'a':
                self._publish(0.0,  self.ang, f"cmd: left     w={ self.ang:.2f}")
            elif c == 'd':
                self._publish(0.0, -self.ang, f"cmd: right    w={-self.ang:.2f}")
            elif c == ' ':
                self._publish(0.0, 0.0, "cmd: stop")
            elif c == '1':
                self.lin = max(0.05, round(self.lin - 0.05, 3))
                self.get_logger().info(f"linear = {self.lin:.2f} m/s")
            elif c == '2':
                self.lin = min(1.50, round(self.lin + 0.05, 3))
                self.get_logger().info(f"linear = {self.lin:.2f} m/s")
            elif c == '9':
                self.ang = max(0.20, round(self.ang - 0.10, 3))
                self.get_logger().info(f"angular = {self.ang:.2f} rad/s")
            elif c == '0':
                self.ang = min(4.00, round(self.ang + 0.10, 3))
                self.get_logger().info(f"angular = {self.ang:.2f} rad/s")
            elif c == 'r':
                self._reset_slam()
            elif c == 'q':
                break

def main():
    rclpy.init()
    node = WasdTeleop()
    try:
        node.spin_keys()
    finally:
        # send a final stop for safety
        msg = Twist()
        node.pub.publish(msg)
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

# `wasd_teleop_with_slam_reset.py`
```
#!/usr/bin/env python3
import sys, termios, tty, subprocess, threading, time, os

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist

HELP = """
WASD teleop  (/cmd_vel)
-----------------------
  W : forward      S : backward
  A : turn left    D : turn right
  Space : stop     Q : quit
  R : reset SLAM (kill + restart after 10 s)

  1/2 : linear speed -/+ (default 0.30 m/s)
  9/0 : angular speed -/+ (default 1.20 rad/s)
"""

# Path to your slam params
SLAM_PARAMS = os.path.expanduser(
    "~/Desktop/ros2_mapping_project/slam_params.yaml"
)

SLAM_CMD = [
    "ros2", "run", "slam_toolbox", "sync_slam_toolbox_node",
    "--ros-args", "--params-file", SLAM_PARAMS,
]


def getch():
    fd = sys.stdin.fileno()
    if not sys.stdin.isatty():
        return ''  # ignore if not a TTY
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return ch


class WasdTeleop(Node):
    def __init__(self):
        super().__init__('wasd_teleop')
        self.pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.lin = 0.30
        self.ang = 1.20
        self.slam_proc = None
        self.reset_in_progress = False

        self.get_logger().info(HELP)
        self.get_logger().info("Teleop ready. Make sure motor driver is running and listening to /cmd_vel.")

    # ----------------- SLAM control helpers -----------------

    def start_slam(self):
        # If already running, do nothing
        if self.slam_proc is not None and self.slam_proc.poll() is None:
            return
        self.get_logger().info(
            f"Starting slam_toolbox with params: {SLAM_PARAMS}"
        )
        try:
            self.slam_proc = subprocess.Popen(SLAM_CMD)
        except Exception as e:
            self.get_logger().error(f"Failed to start slam_toolbox: {e}")
            self.slam_proc = None

    def stop_slam(self):
        # Stop the process we launched (if any)
        if self.slam_proc is not None and self.slam_proc.poll() is None:
            self.get_logger().info("Stopping slam_toolbox (owned process)...")
            self.slam_proc.terminate()
            try:
                self.slam_proc.wait(timeout=5.0)
            except subprocess.TimeoutExpired:
                self.get_logger().warn("slam_toolbox did not exit, killing...")
                self.slam_proc.kill()
            self.slam_proc = None

        # Backup: kill any sync_slam_toolbox_node processes
        try:
            subprocess.run(
                ["pkill", "-f", "slam_toolbox.*sync_slam_toolbox_node"],
                check=False,
            )
        except Exception as e:
            self.get_logger().warn(f"pkill backup failed: {e}")

    def reset_slam_with_delay(self, delay_sec: float = 10.0):
        if self.reset_in_progress:
            self.get_logger().warn("SLAM reset already in progress, ignoring.")
            return

        self.reset_in_progress = True

        def worker():
            try:
                self.get_logger().info(
                    f"SLAM reset requested. Stopping slam_toolbox and "
                    f"waiting {delay_sec:.1f} s before restart..."
                )
                # Stop SLAM immediately
                self.stop_slam()
                # Wait so you can reposition robot, etc.
                time.sleep(delay_sec)
                # Restart SLAM
                self.start_slam()
                self.get_logger().info("SLAM restarted. You can start mapping again.")
            finally:
                self.reset_in_progress = False

        t = threading.Thread(target=worker, daemon=True)
        t.start()

    # ----------------- Teleop logic -----------------

    def _publish(self, vx, wz, note=''):
        msg = Twist()
        msg.linear.x = float(vx)
        msg.angular.z = float(wz)
        self.pub.publish(msg)
        if note:
            self.get_logger().info(note)

    def spin_keys(self):
        self._publish(0.0, 0.0, "ready: WASD, space=stop, r=reset SLAM, q=quit")
        while rclpy.ok():
            c = getch()
            if not c:
                continue

            c_lower = c.lower()
            self.get_logger().debug(f"Key pressed: {repr(c)}")

            if   c_lower == 'w':
                self._publish(self.lin, 0.0, f"cmd: forward  v={self.lin:.2f}")
            elif c_lower == 's':
                self._publish(-self.lin, 0.0, f"cmd: back     v={-self.lin:.2f}")
            elif c_lower == 'a':
                self._publish(0.0, self.ang, f"cmd: left     w={self.ang:.2f}")
            elif c_lower == 'd':
                self._publish(0.0, -self.ang, f"cmd: right    w={-self.ang:.2f}")
            elif c == ' ':
                self._publish(0.0, 0.0, "cmd: stop")

            # Speed tweaks
            elif c == '1':
                self.lin = max(0.05, round(self.lin - 0.05, 3))
                self.get_logger().info(f"linear = {self.lin:.2f} m/s")
            elif c == '2':
                self.lin = min(1.50, round(self.lin + 0.05, 3))
                self.get_logger().info(f"linear = {self.lin:.2f} m/s")
            elif c == '9':
                self.ang = max(0.20, round(self.ang - 0.10, 3))
                self.get_logger().info(f"angular = {self.ang:.2f} rad/s")
            elif c == '0':
                self.ang = min(4.00, round(self.ang + 0.10, 3))
                self.get_logger().info(f"angular = {self.ang:.2f} rad/s")

            # --- SLAM reset hotkey ---
            elif c_lower == 'r':
                self._publish(0.0, 0.0, "cmd: stop (SLAM reset requested)")
                self.reset_slam_with_delay(delay_sec=10.0)

            elif c_lower == 'q':
                self.get_logger().info("Quit requested, stopping teleop.")
                break


def main():
    rclpy.init()
    node = WasdTeleop()
    try:
        node.spin_keys()
    finally:
        # final stop for safety
        msg = Twist()
        node.pub.publish(msg)
        node.stop_slam()
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

# `config/motor_driver.yaml`
```
motor_driver_node:
  ros__parameters:
    ena: 15
    enb: 32
    in1: 23
    in2: 19
    in3: 21
    in4: 18
    cmd_topic: "/cmd_vel"
    pwm_freq_hz: 1000.0
    min_duty_pct: 20.0
    min_speed_enable: 0.01
    brake_on_zero: true
    invert_left: false
    invert_right: false
```

# `config/slam_params.yaml`
```
slam_toolbox:
  ros__parameters:
    mode: "mapping"

    # Frames
    odom_frame: "odom"
    map_frame: "map"
    base_frame: "base_link"
    scan_topic: "/scan"

    # TF / timing
    transform_publish_period: 0.05        # publish map->odom at 20 Hz
    transform_timeout: 0.2
    tf_buffer_duration: 30.0
    scan_queue_size: 10                   # name in docs; not "queue_size"
    throttle_scans: 1

    # Laser limits (match your RPLidar)
    min_laser_range: 0.2
    max_laser_range: 12.0

    # Motion gating
    minimum_travel_distance: 0.05
    minimum_travel_heading: 0.05
    minimum_time_interval: 0.0

    # Matching
    use_scan_matching: true
    use_scan_barycenter: false

    # Map
    resolution: 0.05
    map_update_interval: 0.2
```

# `config/twist_mux.yaml`
```

twist_mux:
  ros__parameters:
    topics:
      - name: nav2
        topic: /cmd_vel_smoothed
        timeout: 0.5
        priority: 50
      - name: avoid
        topic: /obstacle_avoidance/cmd_vel
        timeout: 0.3
        priority: 70
    locks:
      - name: estop
        topic: /obstacle_detected
        timeout: 0.0
        priority: 255```

# `launch/bringup.launch.py`
```
#!/usr/bin/env python3
"""Bringup for mapping stack: TFs, RPLidar, IMU+filter, encoders, EKF, SLAM, RViz."""

import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import SetEnvironmentVariable
from launch_ros.actions import Node


def generate_launch_description():
    package_name = 'ros2_mapping_project'
    share_dir = get_package_share_directory(package_name)

    odom_params = os.path.join(share_dir, 'odom_params.yaml')
    slam_params = os.path.join(share_dir, 'slam_params.yaml')
    imu_filter_params = os.path.join(share_dir, 'imu_filter_params.yaml')

    return LaunchDescription([
        # Ensure FastDDS SHM off (same as your scripts)
        SetEnvironmentVariable(name='FASTDDS_TRANSPORT_SHARED_MEM', value='off'),

        # ----- Static TFs -----
        # Lidar a bit forward of the rotation center (adjust 0.12 to your real offset)
        Node(
            package='tf2_ros',
            executable='static_transform_publisher',
            name='laser_base_tf',
            arguments=['0.12', '0.0', '0.10', '0', '0', '0', 'base_link', 'laser'],
            output='screen',
        ),
        Node(
            package='tf2_ros',
            executable='static_transform_publisher',
            name='imu_base_tf',
            arguments=['0', '0', '0.05', '0', '0', '0', 'base_link', 'imu_link'],
            output='screen',
        ),

        # ----- RPLidar -----
        Node(
            package='rplidar_ros',
            executable='rplidar_node',
            name='rplidar_node',
            output='screen',
            parameters=[{
                'serial_port': '/dev/rplidar',
                'serial_baudrate': 115200,
                'frame_id': 'laser',
                'angle_compensate': True,
            }],
        ),

        # ----- IMU + Madgwick filter: /imu/raw -> /imu/data -----
        Node(
            package=package_name,
            executable='imu_node',
            name='imu_node',
            output='screen',
            parameters=[{'bus': 7, 'address': 0x28}],
        ),
        Node(
            package='imu_filter_madgwick',
            executable='imu_filter_madgwick_node',
            name='imu_filter',
            output='screen',
            parameters=[imu_filter_params, {
                'use_mag': False,
                'publish_tf': False,
                'world_frame': 'enu',
            }],
            remappings=[
                ('/imu/data_raw', '/imu/raw'),
                ('/imu/data', '/imu/data'),
            ],
        ),

        # ----- Encoders: /wheel_twist -----
        Node(
            package=package_name,
            executable='encoders_node',
            name='encoders_node',
            output='screen',
            parameters=[{
                'left_A': 12,
                'left_B': 16,
                'right_A': 7,
                'right_B': 11,
                'wheel_radius': 0.05,
                'wheel_base': 0.24,
                'ticks_per_rev': 333.3333,
                'publish_rate_hz': 20.0,
            }],
        ),

        # ----- EKF (robot_localization) -----
        Node(
            package='robot_localization',
            executable='ekf_node',
            name='ekf_filter_node',
            output='screen',
            parameters=[odom_params],
        ),

        # ----- SLAM Toolbox (sync, mapping mode) -----
        Node(
            package='slam_toolbox',
            executable='sync_slam_toolbox_node',
            name='slam_toolbox',
            output='screen',
            parameters=[slam_params],
        ),

        # ----- RViz2 -----
        Node(
            package='rviz2',
            executable='rviz2',
            name='rviz2',
            output='screen',
        ),
    ])
```

# `launch/bringup_gpio.launch.py`
```
#!/usr/bin/env python3
"""Composite launch for Nav2, sensor stack, and GPIO drivetrain."""

import os, math
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import (
    DeclareLaunchArgument, LogInfo, OpaqueFunction, IncludeLaunchDescription,
    SetEnvironmentVariable
)
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node


def _as_bool(value: str) -> bool:
    return value.lower() in {"1", "true", "t", "yes", "on"}

def _declare_argument(name: str, default: str, description: str) -> DeclareLaunchArgument:
    return DeclareLaunchArgument(name, default_value=default, description=description)

def _launch_setup(context, *args, **kwargs):
    actions = []
    package_name = 'ros2_mapping_project'
    share_dir = get_package_share_directory(package_name)

    # ----- Feature toggles -----
    use_internal_lidar      = _as_bool(LaunchConfiguration('use_internal_lidar').perform(context))
    use_motor_driver        = _as_bool(LaunchConfiguration('use_motor_driver').perform(context))
    use_nav2                = _as_bool(LaunchConfiguration('use_nav2').perform(context))
    use_teleop              = _as_bool(LaunchConfiguration('use_teleop').perform(context))

    # ----- File paths / configs -----
    nav2_params         = LaunchConfiguration('nav2_params').perform(context)
    ekf_config          = LaunchConfiguration('ekf_config').perform(context)
    twist_mux_config    = LaunchConfiguration('twist_mux_config').perform(context)
    robot_description_file = LaunchConfiguration('robot_description_file').perform(context)

    # ----- Kinematics / encoders -----
    wheel_separation = LaunchConfiguration('wheel_separation').perform(context)
    wheel_radius     = LaunchConfiguration('wheel_radius').perform(context)
    enc_tpr          = LaunchConfiguration('encoder_ticks_per_rev').perform(context)

    def _as_float(s):
        try:
            return float(s) if s not in ("", None) else None
        except ValueError:
            return None

    L  = _as_float(wheel_separation) or 0.24
    r  = _as_float(wheel_radius)     or 0.05
    tpr= _as_float(enc_tpr)          or 333.3333

    # Encoder pins
    try:    left_A_pin  = int(LaunchConfiguration('left_A_pin').perform(context))
    except: left_A_pin  = 12
    try:    left_B_pin  = int(LaunchConfiguration('left_B_pin').perform(context))
    except: left_B_pin  = 16
    try:    right_A_pin = int(LaunchConfiguration('right_A_pin').perform(context))
    except: right_A_pin = 7
    try:    right_B_pin = int(LaunchConfiguration('right_B_pin').perform(context))
    except: right_B_pin = 11

    # Motor driver params
    cmd_topic        = LaunchConfiguration('motor_cmd_topic').perform(context)
    max_speed_mps    = LaunchConfiguration('max_speed_mps').perform(context)
    deadband_mps     = LaunchConfiguration('deadband_mps').perform(context)
    pwm_freq_hz      = LaunchConfiguration('pwm_freq_hz').perform(context)
    duty_min         = LaunchConfiguration('duty_min').perform(context)
    left_invert      = LaunchConfiguration('left_invert').perform(context)
    right_invert     = LaunchConfiguration('right_invert').perform(context)
    brake_on_stop    = LaunchConfiguration('brake_on_stop').perform(context)

    slam_params       = os.path.join(share_dir, 'slam_params.yaml')
    imu_filter_params = os.path.join(share_dir, 'imu_filter_params.yaml')

    # ----- Environment (FastDDS SHM off) -----
    actions.append(SetEnvironmentVariable(name='FASTDDS_TRANSPORT_SHARED_MEM', value='off'))

    # ----- Robot description -----
    if robot_description_file:
        if os.path.exists(robot_description_file):
            with open(robot_description_file, 'r', encoding='utf-8') as urdf_file:
                robot_description = urdf_file.read()
            actions.append(Node(
                package='robot_state_publisher',
                executable='robot_state_publisher',
                parameters=[{'robot_description': robot_description}],
                name='robot_state_publisher', output='screen'
            ))
        else:
            actions.append(LogInfo(msg=f'robot_description_file not found: {robot_description_file}'))

    # ----- LiDAR -----
    if use_internal_lidar:
        actions.append(Node(
            package=package_name, executable='lidar_node',
            name='lidar_node', output='screen'
        ))
    else:
        actions.append(Node(
            package='rplidar_ros', executable='rplidar_node',
            name='rplidar_node', output='screen',
            parameters=[{
                'serial_port': '/dev/rplidar',
                'serial_baudrate': 115200,
                'frame_id': 'laser',
                'angle_compensate': True,
            }]
        ))

    # ----- IMU + filter -----
    actions.extend([
        Node(package=package_name, executable='imu_node', name='imu_node', output='screen'),
        Node(
            package='imu_filter_madgwick', executable='imu_filter_madgwick_node',
            name='imu_filter', output='screen',
            parameters=[imu_filter_params, {'use_mag': False, 'publish_tf': False, 'world_frame': 'enu'}],
            remappings=[('/imu/data_raw', '/imu/raw'), ('/imu/data', '/imu/data')]
        ),
    ])

    # ----- Encoders -----
    actions.append(Node(
        package=package_name, executable='encoders_node',
        name='encoders_node', output='screen',
        parameters=[{
            'left_A': left_A_pin, 'left_B': left_B_pin,
            'right_A': right_A_pin, 'right_B': right_B_pin,
            'wheel_radius': r, 'wheel_base': L, 'ticks_per_rev': tpr,
        }]
    ))

    # ----- Static TFs -----
    actions.extend([
        Node(
            package='tf2_ros',
            executable='static_transform_publisher',
            name='laser_base_tf',
            arguments=['0.12', '0.0', '0.10', '0', '0', '0', 'base_link', 'laser'],
        ),
        Node(
            package='tf2_ros',
            executable='static_transform_publisher',
            name='imu_base_tf',
            arguments=['0', '0', '0.05', '0', '0', '0', 'base_link', 'imu_link'],
        ),
    ])

    # ----- SLAM (EKF + SLAM Toolbox) -----
    actions.append(IncludeLaunchDescription(
        PythonLaunchDescriptionSource(os.path.join(share_dir, 'launch', 'slam.launch.py')),
        launch_arguments={
            'ekf_config': ekf_config,
            'slam_params_file': slam_params,
        }.items(),
    ))

    # ----- Nav2 velocity smoother -----
    actions.append(Node(
        package='nav2_velocity_smoother', executable='velocity_smoother',
        name='velocity_smoother', output='screen',
        remappings=[('cmd_vel', '/cmd_vel'), ('cmd_vel_smoothed', '/cmd_vel_smoothed')]
    ))

    # ----- twist_mux -----
    if twist_mux_config and os.path.exists(twist_mux_config):
        actions.append(Node(
            package='twist_mux', executable='twist_mux',
            name='twist_mux', output='screen',
            parameters=[twist_mux_config],
            remappings=[('cmd_vel_out', '/cmd_vel_out')]
        ))
    else:
        actions.append(LogInfo(msg=f'twist_mux_config not found; expected at {twist_mux_config}'))

    # ----- Motor driver (GPIO + PWM) -----
    if use_motor_driver:
        actions.append(Node(
            package=LaunchConfiguration('motor_driver_package').perform(context),
            executable=LaunchConfiguration('motor_driver_executable').perform(context),
            name='motor_driver_node', output='screen',
            parameters=[{
                'cmd_topic':     cmd_topic or '/cmd_vel_out',
                'wheel_base':    L,
                'max_speed_mps': float(max_speed_mps or 0.6),
                'deadband_mps':  float(deadband_mps or 0.03),
                'pwm_freq_hz':   int(pwm_freq_hz or 500),
                'duty_min':      float(duty_min or 15.0),
                'left_invert':   _as_bool(left_invert or 'false'),
                'right_invert':  _as_bool(right_invert or 'false'),
                'brake_on_stop': _as_bool(brake_on_stop or 'true'),
            }]
        ))

    # ----- Optional teleop for bench testing -----
    if use_teleop:
        actions.append(Node(
            package='teleop_twist_keyboard', executable='teleop_twist_keyboard',
            name='teleop', output='screen',
            remappings=[('cmd_vel', '/cmd_vel')],
            prefix=['xterm -e ']  # opens in a terminal so you can press keys
        ))

    # ----- Nav2 bringup -----
    if use_nav2:
        if nav2_params and os.path.exists(nav2_params):
            nav2_bringup_dir = get_package_share_directory('nav2_bringup')
            actions.append(IncludeLaunchDescription(
                PythonLaunchDescriptionSource(os.path.join(nav2_bringup_dir, 'launch', 'bringup_launch.py')),
                launch_arguments={'use_sim_time': 'false', 'params_file': nav2_params}.items()
            ))
        else:
            actions.append(LogInfo(msg=f'Nav2 params file not found; expected at {nav2_params}'))

    return actions


def generate_launch_description():
    package_name = 'ros2_mapping_project'
    share_dir = get_package_share_directory(package_name)

    default_ekf       = os.path.join(share_dir, 'odom_params.yaml')
    default_twist_mux = os.path.join(share_dir, 'config', 'twist_mux.yaml')

    ld = LaunchDescription()

    # Feature toggles
    ld.add_action(_declare_argument('use_internal_lidar', 'false', 'Use the custom lidar_node instead of rplidar_ros.'))
    ld.add_action(_declare_argument('use_motor_driver', 'true',  'Launch the GPIO motor driver node.'))
    ld.add_action(_declare_argument('use_nav2', 'true', 'Start the Nav2 bringup launch file.'))
    ld.add_action(_declare_argument('use_teleop', 'false', 'Start teleop_twist_keyboard for manual control.'))

    # Files
    ld.add_action(_declare_argument('nav2_params', default=os.path.join(share_dir, 'nav2_params.yaml'),
                                    description='Nav2 params YAML file.'))
    ld.add_action(_declare_argument('ekf_config', default_ekf, 'robot_localization EKF config file.'))
    ld.add_action(_declare_argument('twist_mux_config', default_twist_mux, 'twist_mux configuration file.'))
    ld.add_action(_declare_argument('robot_description_file', os.path.join(share_dir, 'description', 'robot.urdf'),
                                    'Path to the robot URDF file.'))

    # Geometry / encoders
    ld.add_action(_declare_argument('wheel_separation', '0.24', 'Distance between the drive wheels (meters).'))
    ld.add_action(_declare_argument('wheel_radius',     '0.05', 'Drive wheel radius (meters).'))
    ld.add_action(_declare_argument('encoder_ticks_per_rev', '333.3333', 'Encoder ticks per wheel revolution.'))
    ld.add_action(_declare_argument('left_A_pin',  '12', 'BOARD pin number for the left encoder phase A.'))
    ld.add_action(_declare_argument('left_B_pin',  '16', 'BOARD pin number for the left encoder phase B.'))
    ld.add_action(_declare_argument('right_A_pin', '7',  'BOARD pin number for the right encoder phase A.'))
    ld.add_action(_declare_argument('right_B_pin', '11', 'BOARD pin number for the right encoder phase B.'))


    # Motor driver parameters
    ld.add_action(_declare_argument('motor_driver_package',    package_name, 'Package name for the GPIO motor driver node.'))
    ld.add_action(_declare_argument('motor_driver_executable', 'motor_driver_node', 'Executable for the GPIO motor driver.'))
    ld.add_action(_declare_argument('motor_cmd_topic', '/cmd_vel_out', 'Which Twist topic to listen to (e.g., /cmd_vel_out or /cmd_vel).'))
    ld.add_action(_declare_argument('max_speed_mps',  '0.6',  'Speed corresponding to 100% duty.'))
    ld.add_action(_declare_argument('deadband_mps',   '0.03', 'Below this speed, output 0 duty.'))
    ld.add_action(_declare_argument('pwm_freq_hz',    '500',  'PWM frequency (Hz).'))
    ld.add_action(_declare_argument('duty_min',       '22.0', 'Minimum duty to overcome stiction.'))
    ld.add_action(_declare_argument('left_invert',    'false','Invert left direction.'))
    ld.add_action(_declare_argument('right_invert',   'false','Invert right direction.'))
    ld.add_action(_declare_argument('brake_on_stop',  'true', 'Active brake (both highs) instead of coast on stop.'))

    ld.add_action(OpaqueFunction(function=_launch_setup))
    return ld
```

# `launch/nav2_navigation.launch.py`
```
#!/usr/bin/env python3
"""Minimal Nav2 launch hooking to ros2_mapping_project/nav2_params.yaml."""

import os

from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration


def generate_launch_description():
    pkg_share = get_package_share_directory('ros2_mapping_project')
    default_nav2_params = os.path.join(pkg_share, 'nav2_params.yaml')

    nav2_params = LaunchConfiguration('nav2_params')

    return LaunchDescription([
        DeclareLaunchArgument(
            'nav2_params',
            default_value=default_nav2_params,
            description='Full path to the Nav2 params YAML file',
        ),
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource(
                os.path.join(
                    get_package_share_directory('nav2_bringup'),
                    'launch',
                    'navigation_launch.py',
                )
            ),
            launch_arguments={
                'use_sim_time': 'false',
                'autostart': 'true',
                'params_file': nav2_params,
            }.items(),
        ),
    ])```

# `launch/slam.launch.py`
```
#!/usr/bin/env python3
"""Launch file for SLAM Toolbox and EKF."""

import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, RegisterEventHandler
from launch.event_handlers import OnProcessStart
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node

def generate_launch_description():
    """Launch the EKF and SLAM Toolbox nodes in the correct order."""
    pkg_share = get_package_share_directory('ros2_mapping_project')

    ekf_config_path = os.path.join(pkg_share, 'odom_params.yaml')
    slam_params_path = os.path.join(pkg_share, 'slam_params.yaml')

    ekf_config = LaunchConfiguration('ekf_config', default=ekf_config_path)
    slam_params_file = LaunchConfiguration('slam_params_file', default=slam_params_path)

    ekf_node = Node(
        package='robot_localization',
        executable='ekf_node',
        name='ekf_filter_node',
        output='screen',
        parameters=[ekf_config]
    )

    slam_toolbox_node = Node(
        package='slam_toolbox',
        executable='sync_slam_toolbox_node',
        name='slam_toolbox',
        output='screen',
        parameters=[slam_params_file]
    )

    return LaunchDescription([
        DeclareLaunchArgument(
            'ekf_config',
            default_value=ekf_config_path,
            description='Path to the EKF parameters file.'
        ),
        DeclareLaunchArgument(
            'slam_params_file',
            default_value=slam_params_path,
            description='Path to the SLAM Toolbox parameters file.'
        ),
        ekf_node,
        RegisterEventHandler(
            event_handler=OnProcessStart(
                target_action=ekf_node,
                on_start=[slam_toolbox_node]
            )
        )
    ])```

# `readme/readme.txt`
```
//setup

1. Clean Enviornment and TF: (Terminal A)
unset $(env | awk -F= '/^(AMENT|COLCON|ROS_|RMW_|CYCLONEDDS)/{print $1}')
source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off

ros2 run tf2_ros static_transform_publisher 0 0 0.10 0 0 0 base_link laser &
ros2 run tf2_ros static_transform_publisher 0 0 0.05  0 0 0 base_link imu_link &


2. Run simulated Odometer: (Terminal B)

python3 ~/Desktop/ros2_mapping_project/pseudo_odom_node.py

3. Run IMU: (Terminal C)

source /opt/ros/humble/setup.bash
python3 ~/Desktop/ros2_mapping_project/imu_bno055_smbus.py --ros-args -p bus:=7 -p address:=0x28

4. Run LiDAR: (Terminal D)

source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off
ros2 run rplidar_ros rplidar_node --ros-args \
  -p serial_port:=/dev/rplidar \
  -p serial_baudrate:=115200 \
  -p frame_id:=laser \
  -p angle_compensate:=true

5. Run Slam: (Terminal E)

source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off
ros2 launch slam_toolbox online_async_launch.py \
  slam_params_file:=$HOME/Desktop/ros2_mapping_project/slam_params.yaml


6. Run RVIZ: (Terminal F)

source /opt/ros/humble/setup.bash
rviz2```

# `readme/readme2.txt`
```
export FASTDDS_TRANSPORT_SHARED_MEM=off
ros2 launch ros2_mapping_project bringup_gpio.launch.py \
  use_nav2:=true \
  use_motor_driver:=false \
  use_diff_drive_odometry:=false \
  left_A_pin:=12 left_B_pin:=16 \
  right_A_pin:=7  right_B_pin:=11



ros2 topic echo /left_wheel/velocity
ros2 topic echo /left_wheel/direction
ros2 topic echo /right_wheel/velocity
ros2 topic echo /right_wheel/direction
ros2 topic echo /left_wheel/ticks
ros2 topic echo /right_wheel/ticks
ros2 topic echo /wheel_odom



export FASTDDS_TRANSPORT_SHARED_MEM=off
ros2 launch ros2_mapping_project bringup_gpio.launch.py \
  use_nav2:=true \
  use_motor_driver:=true \
  use_diff_drive_odometry:=false \
  left_A_pin:=12 left_B_pin:=16 \
  right_A_pin:=7  right_B_pin:=11

  
source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off
python3 encoders_node.py --ros-args \
  -p left_A:=12 -p left_B:=16 -p right_A:=7 -p right_B:=11 \
  -p wheel_radius:=0.05 -p wheel_base:=0.24 -p ticks_per_rev:=333.3333

   # more sensitive: accept closer edges, count both channels

python3 encoders_node.py --ros-args \
  -p left_A:=7 -p left_B:=11 -p right_A:=12 -p right_B:=16 \
  -p left_active_low:=true -p right_active_low:=true \
  -p left_only_A_edges:=false -p right_only_A_edges:=false \
  -p edge_min_us:=200  -p debounce_ms:=0 \
  -p publish_rate_hz:=20.0 \
  -p wheel_radius:=0.05 -p wheel_base:=0.24 -p ticks_per_rev:=333.3333


#MOTOR DRIVER



 # Terminal 2 – teleop (your WASD script from before)
source /opt/ros/humble/setup.bash
python3 wasd_teleop.py    # publishes to /cmd_vel





./bringup_slam_stack.sh




 source /opt/ros/humble/setup.bash
python3 motor_driver_pca_reg_dual.py --ros-args \
  -p ena_addr:="'0x41'" -p enb_addr:="'0x60'" \
  -p ena_channel:=0 -p in1_channel:=1 -p in2_channel:=2 \
  -p enb_channel:=0 -p in3_channel:=1 -p in4_channel:=2 \
  -p pwm_freq_hz:=1000.0 \
  -p max_lin:=0.8 -p max_ang_cmd:=1.2 -p deadband:=0.03 \
  -p min_duty_pct:=80.0 -p brake_on_zero:=false \
  -p invert_right:=true -p invert_left:=false \
  -p map_enA_to_left:=true


./bringup_slam_stack.sh

#run nav2_bringup

cd ~/Desktop/ros2_mapping_project
source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off

ros2 launch nav2_bringup navigation_launch.py \
  use_sim_time:=false \
  autostart:=true \
  params_file:=/home/team4/Desktop/ros2_mapping_project/nav2_min.yaml


#camera approach code

export FASTDDS_TRANSPORT_SHARED_MEM=off
python3 enemy_approach_node.py





[INFO] [1762304820.177712912] [motor_driver_pca_dual]: PCA A=0x41 (EnA=0, In1=1, In2=2) | PCA B=0x60 (EnB=0, In3=1, In4=2) | freq=1000.0Hz min_duty=35%
```

# `readme/readme3.txt`
```
readme
//set up LiDAR

source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off
ros2 run rplidar_ros rplidar_node --ros-args \
  -p serial_port:=/dev/rplidar \
  -p serial_baudrate:=115200 \
  -p frame_id:=laser \
  -p angle_compensate:=true

//set up imu

source /opt/ros/humble/setup.bash
python3 ~/Desktop/ros2_mapping_project/imu_bno055_smbus.py --ros-args -p bus:=7 -p address:=0x28

//set up encoders

source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off
python3 encoders_node.py --ros-args \
  -p left_A:=7 -p left_B:=11 -p right_A:=12 -p right_B:=16 \
  -p left_active_low:=true -p right_active_low:=true \
  -p left_only_A_edges:=false -p right_only_A_edges:=false \
  -p edge_min_us:=200  -p debounce_ms:=0 \
  -p publish_rate_hz:=20.0 \
  -p wheel_radius:=0.05 -p wheel_base:=0.24 -p ticks_per_rev:=333.3333

//set up robot locolization

d ~/Desktop/ros2_mapping_project
source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off

ros2 run robot_localization ekf_node --ros-args \
  -r __node:=ekf_filter_node \
  --params-file ~/Desktop/ros2_mapping_project/config/ekf.yaml

//setup slam mapping

cd ~/Desktop/ros2_mapping_project
source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off

ros2 run slam_toolbox sync_slam_toolbox_node --ros-args \
  --params-file ~/Desktop/ros2_mapping_project/slam_params.yaml

//set up link

unset $(env | awk -F= '/^(AMENT|COLCON|ROS_|RMW_|CYCLONEDDS)/{print $1}')
source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off

ros2 run tf2_ros static_transform_publisher 0 0 0.10 0 0 0 base_link laser &
ros2 run tf2_ros static_transform_publisher 0 0 0.05  0 0 0 base_link imu_link &

//set up ekf

cd ~/Desktop/ros2_mapping_project
source /opt/ros/humble/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off

ros2 run robot_localization ekf_node --ros-args \
  -r __node:=ekf_filter_node \
  --params-file ~/Desktop/ros2_mapping_project/config/ekf.yaml


//set up rviz

source /opt/ros/humble/setup.bash
rviz2

//perform git push

cd ~/Desktop/ros2_mapping_project
git status
git rev-parse --abbrev-ref HEAD         # expect: main
git rev-parse --abbrev-ref @{u}         # expect: origin/main
echo "# ping $(date)" >> .vscode_git_ping.txt
git add .vscode_git_ping.txt
git commit -m "Ping after reboot"
git push

//Runs Slam

./bringup_slam_stack.sh

//wasd teleop

python3 wasd_teleop_with_slam_reset.py

//ROSBridge to Tablet

ros2 launch rosbridge_server rosbridge_websocket_launch.xml


cd ~/Desktop/ros2_mapping_project
source /opt/ros/humble/setup.bash
source install/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off

ros2 launch ros2_mapping_project bringup.launch.py

source /opt/ros/humble/setup.bash
source install/setup.bash
export FASTDDS_TRANSPORT_SHARED_MEM=off

ros2 launch ros2_mapping_project bringup.launch.py
```

# `ros2_mapping_project/__init__.py`
```
```

